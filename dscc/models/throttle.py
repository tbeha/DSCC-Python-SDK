# coding: utf-8

"""
    Data Services Cloud Console API

    Data Services Cloud Console API

    The version of the OpenAPI document: 1.6.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class Throttle(BaseModel):
    """
    A single throttle for the partner.
    """ # noqa: E501
    creation_time: Optional[StrictInt] = Field(default=None, description="Creation time of the throttle.")
    days: Optional[StrictStr] = Field(default=None, description="List of days that the throttle operates.")
    description: Optional[StrictStr] = Field(default=None, description="Description of the throttle.")
    id: Optional[StrictStr] = Field(default=None, description="Id of the throttle.")
    last_modified: Optional[StrictInt] = Field(default=None, description="Last modification time of the throttle.")
    name: Optional[StrictStr] = Field(default=None, description="Name of the throttle.")
    thr_at_time: Optional[StrictInt] = Field(default=None, description="Start time set for the throttle.")
    thr_bandwidth: Optional[StrictInt] = Field(default=None, description="Bandwidth set for the throttle in megabits per second or as the largest possible 64-bit signed integer (9223372036854775807) to indicate that there is no limit. This attribute is superseded by thr_bandwidth_limit_kbps.")
    thr_bandwidth_kbps: Optional[StrictInt] = Field(default=None, description="Bandwidth set for the throttle in kilobits per second or as the largest possible 64-bit signed integer (9223372036854775807) to indicate that there is no limit. This atttibute is superseded by thr_bandwidth_limit_kbps.")
    thr_bandwidth_limit_kbps: Optional[StrictInt] = Field(default=None, description="Bandwidth set for the throttle in kilobits per second or -1 to indicate that there is no limit.")
    thr_day_mask: Optional[StrictInt] = Field(default=None, description="Mask for days that the throttle operates.")
    thr_partner_id: Optional[StrictStr] = Field(default=None, description="ID of the partner object.")
    thr_until_time: Optional[StrictInt] = Field(default=None, description="End time set for the throttle.")
    __properties: ClassVar[List[str]] = ["creation_time", "days", "description", "id", "last_modified", "name", "thr_at_time", "thr_bandwidth", "thr_bandwidth_kbps", "thr_bandwidth_limit_kbps", "thr_day_mask", "thr_partner_id", "thr_until_time"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Throttle from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if creation_time (nullable) is None
        # and model_fields_set contains the field
        if self.creation_time is None and "creation_time" in self.model_fields_set:
            _dict['creation_time'] = None

        # set to None if days (nullable) is None
        # and model_fields_set contains the field
        if self.days is None and "days" in self.model_fields_set:
            _dict['days'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if last_modified (nullable) is None
        # and model_fields_set contains the field
        if self.last_modified is None and "last_modified" in self.model_fields_set:
            _dict['last_modified'] = None

        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if thr_at_time (nullable) is None
        # and model_fields_set contains the field
        if self.thr_at_time is None and "thr_at_time" in self.model_fields_set:
            _dict['thr_at_time'] = None

        # set to None if thr_bandwidth (nullable) is None
        # and model_fields_set contains the field
        if self.thr_bandwidth is None and "thr_bandwidth" in self.model_fields_set:
            _dict['thr_bandwidth'] = None

        # set to None if thr_bandwidth_kbps (nullable) is None
        # and model_fields_set contains the field
        if self.thr_bandwidth_kbps is None and "thr_bandwidth_kbps" in self.model_fields_set:
            _dict['thr_bandwidth_kbps'] = None

        # set to None if thr_bandwidth_limit_kbps (nullable) is None
        # and model_fields_set contains the field
        if self.thr_bandwidth_limit_kbps is None and "thr_bandwidth_limit_kbps" in self.model_fields_set:
            _dict['thr_bandwidth_limit_kbps'] = None

        # set to None if thr_day_mask (nullable) is None
        # and model_fields_set contains the field
        if self.thr_day_mask is None and "thr_day_mask" in self.model_fields_set:
            _dict['thr_day_mask'] = None

        # set to None if thr_partner_id (nullable) is None
        # and model_fields_set contains the field
        if self.thr_partner_id is None and "thr_partner_id" in self.model_fields_set:
            _dict['thr_partner_id'] = None

        # set to None if thr_until_time (nullable) is None
        # and model_fields_set contains the field
        if self.thr_until_time is None and "thr_until_time" in self.model_fields_set:
            _dict['thr_until_time'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Throttle from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "creation_time": obj.get("creation_time"),
            "days": obj.get("days"),
            "description": obj.get("description"),
            "id": obj.get("id"),
            "last_modified": obj.get("last_modified"),
            "name": obj.get("name"),
            "thr_at_time": obj.get("thr_at_time"),
            "thr_bandwidth": obj.get("thr_bandwidth"),
            "thr_bandwidth_kbps": obj.get("thr_bandwidth_kbps"),
            "thr_bandwidth_limit_kbps": obj.get("thr_bandwidth_limit_kbps"),
            "thr_day_mask": obj.get("thr_day_mask"),
            "thr_partner_id": obj.get("thr_partner_id"),
            "thr_until_time": obj.get("thr_until_time")
        })
        return _obj


