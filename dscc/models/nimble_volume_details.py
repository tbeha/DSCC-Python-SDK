# coding: utf-8

"""
    Data Services Cloud Console API

    Data Services Cloud Console API

    The version of the OpenAPI document: 1.6.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from dscc.models.access_control_record import AccessControlRecord
from dscc.models.associated_links_inner import AssociatedLinksInner
from dscc.models.key_value import KeyValue
from dscc.models.nimble_common_resource_attributes import NimbleCommonResourceAttributes
from dscc.models.nimble_volume_export_details import NimbleVolumeExportDetails
from dscc.models.snap_summary import SnapSummary
from dscc.models.snapshot_from_volume import SnapshotFromVolume
from typing import Optional, Set
from typing_extensions import Self

class NimbleVolumeDetails(BaseModel):
    """
    NimbleVolumeDetails
    """ # noqa: E501
    request_uri: Optional[StrictStr] = Field(default=None, description="requestUri for detailed volume objects", alias="requestUri")
    base_snap_id: Optional[StrictStr] = Field(default=None, description="Base snapshot ID. This attribute is required together with name and clone when cloning a volume with the create operation. A 42 digit hexadecimal number.")
    base_snap_name: Optional[StrictStr] = Field(default=None, description="Name of base snapshot. String of up to 215 alphanumeric, hyphenated, colon, or period-separated characters; but cannot begin with hyphen, colon or period. This type is used for object sets containing volumes, snapshots, snapshot collections and protocol endpoints.")
    clone: Optional[StrictBool] = Field(default=None, description="Whether this volume is a clone. Use this attribute in combination with name and base_snap_id to create a clone by setting clone = true.")
    dest_pool_id: Optional[StrictStr] = Field(default=None, description="ID of the destination pool where the volume is moving to. A 42 digit hexadecimal number.")
    dest_pool_name: Optional[StrictStr] = Field(default=None, description="Name of the destination pool where the volume is moving to. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    folder_id: Optional[StrictStr] = Field(default=None, description="ID of the folder holding this volume. An optional NsObjectID. A 42 digit hexadecimal number or the empty string.")
    folder_name: Optional[StrictStr] = Field(default=None, description="Name of the folder holding this volume. It can be empty. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    id: Optional[StrictStr] = Field(default=None, description="Identifier for the volume. A 42 digit hexadecimal number.")
    name: Optional[StrictStr] = Field(default=None, description="Name of the volume. String of up to 215 alphanumeric, hyphenated, colon, or period-separated characters; but cannot begin with hyphen, colon or period.")
    online: Optional[StrictBool] = Field(default=None, description="Online state of volume, available for host initiators to establish connections.")
    owned_by_group: Optional[StrictStr] = Field(default=None, description="Name of group that currently owns the volume. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    owned_by_group_id: Optional[StrictStr] = Field(default=None, description="ID of group that currently owns the volume. A 42 digit hexadecimal number.")
    parent_vol_id: Optional[StrictStr] = Field(default=None, description="Parent volume ID. A 42 digit hexadecimal number.")
    parent_vol_name: Optional[StrictStr] = Field(default=None, description="Name of parent volume. String of up to 215 alphanumeric, hyphenated, colon, or period-separated characters; but cannot begin with hyphen, colon or period. This type is used for object sets containing volumes, snapshots, snapshot collections and protocol endpoints.")
    perfpolicy_id: Optional[StrictStr] = Field(default=None, description="Identifier of the performance policy. After creating a volume, performance policy for the volume can only be changed to another performance policy with same block size. A 42 digit hexadecimal number.")
    perfpolicy_name: Optional[StrictStr] = Field(default=None, description="Name of performance policy. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    pool_id: Optional[StrictStr] = Field(default=None, description="Identifier associated with the pool in the storage pool table. A 42 digit hexadecimal number.")
    pool_name: Optional[StrictStr] = Field(default=None, description="Name of the pool where the volume resides. Volume data will be distributed across arrays over which specified pool is defined. If pool option is not specified, volume is assigned to the default pool. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    read_only: Optional[StrictBool] = Field(default=None, description="Volume is read-only.")
    replication_role: Optional[StrictStr] = Field(default=None, description="Replication role that this volume performs. Possible values: 'periodic_snapshot_downstream', 'synchronous_upstream', 'synchronous_downstream', 'no_replication', 'periodic_snapshot_upstream'.")
    secondary_serial_number: Optional[StrictStr] = Field(default=None, description="Secondary identifier associated with the volume for the SCSI protocol.")
    serial_number: Optional[StrictStr] = Field(default=None, description="Identifier associated with the volume for the SCSI protocol. A 32 digit hexadecimal number.")
    size: Optional[StrictInt] = Field(default=None, description="Volume size in megabytes. Size is required for creating a volume but not for cloning an existing volume.")
    target_name: Optional[StrictStr] = Field(default=None, description="The iSCSI Qualified Name (IQN) or the Fibre Channel World Wide Node Name (WWNN) of the target volume. The iSCSI Qualified Name (IQN) or the Fibre Channel World Wide Node Name (WWNN) of the target.")
    volcoll_id: Optional[StrictStr] = Field(default=None, description="ID of volume collection of which this volume is a member. Use this attribute in update operation to associate or dissociate volumes with or from volume collections. When associating, set this attribute to the ID of the volume collection. When dissociating, set this attribute to empty string. An optional NsObjectID. A 42 digit hexadecimal number or the empty string.")
    volcoll_name: Optional[StrictStr] = Field(default=None, description="Name of volume collection of which this volume is a member. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    access_control_records: Optional[List[Optional[AccessControlRecord]]] = Field(default=None, description="List of access control records that apply to this volume. List of access control records associated with a volume or snapshot or protocol endpoint.")
    agent_type: Optional[StrictStr] = Field(default=None, description="External management agent type. Possible values: 'none', 'smis', 'vvol', 'openstack', 'openstackv2'.")
    app_category: Optional[StrictStr] = Field(default=None, description="Application category that the volume belongs to. Plain string.")
    app_uuid: Optional[StrictStr] = Field(default=None, description="Application identifier of volume. String of up to 255 alphanumeric characters, hyphen, colon, dot and underscore are allowed.")
    associated_links: Optional[List[Optional[AssociatedLinksInner]]] = Field(default=None, description="Associated Links Details")
    block_size: Optional[StrictInt] = Field(default=None, description="Size in bytes of blocks in the volume.")
    cache_needed_for_pin: Optional[StrictInt] = Field(default=None, description="The amount of flash needed to pin the volume.")
    cache_pinned: Optional[StrictBool] = Field(default=None, description="If set to true, all the contents of this volume are kept in flash cache. This provides for consistent performance guarantees for all types of workloads. The amount of flash needed to pin the volume is equal to the limit for the volume.")
    cache_policy: Optional[StrictStr] = Field(default=None, description="Cache policy applied to the volume. Possible values: 'disabled', 'normal', 'aggressive', 'no_write', 'aggressive_read_no_write'.")
    caching_enabled: Optional[StrictBool] = Field(default=None, description="Indicate caching the volume is enabled.")
    cksum_last_verified: Optional[StrictInt] = Field(default=None, description="Last checksum verification time.")
    common_resource_attributes: Optional[NimbleCommonResourceAttributes] = Field(default=None, alias="commonResourceAttributes")
    console_uri: Optional[StrictStr] = Field(default=None, description="consoleUri for detailed storage object", alias="consoleUri")
    content_repl_errors_found: Optional[StrictBool] = Field(default=None, description="Indicates whether the last content based replication had errors.")
    creation_time: Optional[StrictInt] = Field(default=None, description="Time when this volume was created. Seconds since last epoch i.e. 00:00 January 1, 1970.")
    customer_id: Optional[StrictStr] = Field(default=None, description="customerId", alias="customerId")
    dedupe_enabled: Optional[StrictBool] = Field(default=None, description="Indicate whether dedupe is enabled.")
    description: Optional[StrictStr] = Field(default=None, description="Text description of volume. String of up to 255 printable ASCII characters.")
    encryption_cipher: Optional[StrictStr] = Field(default=None, description="The encryption cipher of the volume. Possible values: 'none', 'aes_256_xts'.")
    force: Optional[StrictBool] = Field(default=None, description="Forcibly offline, reduce size or change read-only status a volume.")
    full_name: Optional[StrictStr] = Field(default=None, description="Fully qualified name of volume. String of up to 215 alphanumeric, hyphenated, colon, or period-separated characters; but cannot begin with hyphen, colon or period.")
    generation: Optional[StrictInt] = Field(default=None, description="generation")
    has_locked_snapshots: Optional[StrictBool] = Field(default=None, description="To verify a volume has an immutable snapshot or not.")
    inherit_acl: Optional[StrictBool] = Field(default=None, description="In a volume clone operation, if both the parent and the clone have no external management agent (their agent_type property is \"none\"), then inherit_acl controls whether the clone will inherit a copy of the parent's access control list. If either the parent or the clone have an external management agent, then the clone will not inherit the parent's access control list.")
    is_mfa_protected: Optional[StrictBool] = Field(default=None, description="Protected by multi-factor authentication. Possible values: 'true', 'false'.")
    iscsi_target_scope: Optional[StrictStr] = Field(default=None, description="This indicates whether volume is exported under iSCSI Group Target or iSCSI Volume Target. This attribute is only meaningful to iSCSI system. On FC system, all volumes are exported under the FC Group Target. In create operation, the volume's target type will be set by this attribute. If not specified, it will be set as the group-setting. In clone operation, the clone's target type will inherit from the parent' setting. Possible values: 'volume', 'group'.")
    last_content_snap_br_cg_uid: Optional[StrictInt] = Field(default=None, description="The branch cg uid of the content based snapshot that was last replicated.")
    last_content_snap_br_gid: Optional[StrictInt] = Field(default=None, description="The branch gid of the content based snapshot that was last replicated.")
    last_content_snap_id: Optional[StrictInt] = Field(default=None, description="The ID of the content based snapshot that was last replicated.")
    last_modified: Optional[StrictInt] = Field(default=None, description="Time when this volume was last modified. Seconds since last epoch i.e. 00:00 January 1, 1970.")
    last_snap: Optional[SnapSummary] = None
    limit: Optional[StrictInt] = Field(default=None, description="Limit for the volume as a percentage of volume size. Percentage as integer from 0 to 100.")
    limit_iops: Optional[StrictInt] = Field(default=None, description="IOPS limit for this volume. If limit_iops is not specified when a volume is created, or if limit_iops is set to -1, then the volume has no IOPS limit. If limit_iops is not specified while creating a clone, IOPS limit of parent volume will be used as limit. IOPS limit should be in range [256, 4294967294] or -1 for unlimited. If both limit_iops and limit_mbps are specified, limit_mbps must not be hit before limit_iops. In other words, IOPS and MBPS limits should honor limit_iops _ampersand_amp;lt;= ((limit_mbps MB/s * 2^20 B/MB) / block_size B).")
    limit_mbps: Optional[StrictInt] = Field(default=None, description="Throughput limit for this volume in MB/s. If limit_mbps is not specified when a volume is created, or if limit_mbps is set to -1, then the volume has no MBPS limit. MBPS limit should be in range [1, 4294967294] or -1 for unlimited. If both limit_iops and limit_mbps are specified, limit_mbps must not be hit before limit_iops. In other words, IOPS and MBPS limits should honor limit_iops _ampersand_amp;lt;= ((limit_mbps MB/s * 2^20 B/MB) / block_size B).")
    metadata: Optional[List[Optional[KeyValue]]] = Field(default=None, description="Key-value pairs that augment a volume's attributes. List of key-value pairs. Keys must be unique and non-empty. When creating an object, values must be non-empty. When updating an object, an empty value causes the corresponding key to be removed.")
    move_aborting: Optional[StrictBool] = Field(default=None, description="This indicates whether the move of the volume is aborting or not.")
    move_bytes_migrated: Optional[StrictInt] = Field(default=None, description="The bytes of volume which have been moved.")
    move_bytes_remaining: Optional[StrictInt] = Field(default=None, description="The bytes of volume which have not been moved.")
    move_est_compl_time: Optional[StrictInt] = Field(default=None, description="The estimated time of completion of a move. Seconds since last epoch i.e. 00:00 January 1, 1970.")
    move_start_time: Optional[StrictInt] = Field(default=None, description="The Start time when this volume was moved. Seconds since last epoch i.e. 00:00 January 1, 1970.")
    multi_initiator: Optional[StrictBool] = Field(default=None, description="This indicates whether volume and its snapshots are multi-initiator accessible. This attribute applies only to volumes and snapshots available to iSCSI initiators.Online state of volume, available for host initiators to establish connections.")
    needs_content_repl: Optional[StrictBool] = Field(default=None, description="Indicates whether the volume needs content based replication.")
    num_snaps: Optional[StrictInt] = Field(default=None, description="Number of live, non-hidden snapshots for this volume.")
    offline_reason: Optional[StrictStr] = Field(default=None, description="Volume offline reason. Possible values: 'user', 'recovery', 'replica', 'over_volume_limit', 'over_snapshot_limit', 'over_volume_reserve', 'over_snapshot_reserve', 'nvram_loss_recovery', 'serial_number_collision', 'encryption_inactive', 'encryption_key_deleted', 'vvol_unbind', 'cache_unpin_in_progress'.")
    online_snaps: Optional[List[Optional[SnapshotFromVolume]]] = Field(default=None, description="The list of online snapshots of this volume. Snapshot list as presented in volumes object set.")
    perfpolicy_creator_id: Optional[StrictStr] = Field(default=None, description="Originator id for the associated performance policy.")
    perfpolicy_creator_name: Optional[StrictStr] = Field(default=None, description="Originator name for the associated performance policy.")
    pinned_cache_size: Optional[StrictInt] = Field(default=None, description="The amount of flash pinned on the volume.")
    pre_filter: Optional[StrictStr] = Field(default=None, description="Pre-filtering criteria. Plain string.")
    previously_deduped: Optional[StrictBool] = Field(default=None, description="Indicate whether dedupe has ever been enabled on this volume.")
    projected_num_snaps: Optional[StrictInt] = Field(default=None, description="Depricated. Projected number of snapshots (including schedued and manual) for this volume.")
    protection_type: Optional[StrictStr] = Field(default=None, description="Specifies if volume is protected with schedules. If protected, indicate whether replication is setup. Volume Collection or volume is protected locally or remotely or unprotected. Possible values: 'local', 'remote' or 'unprotected'.")
    reserve: Optional[StrictInt] = Field(default=None, description="Amount of space to reserve for this volume as a percentage of volume size. Percentage as integer either 0 or 100.")
    resource_uri: Optional[StrictStr] = Field(default=None, description="Link to the object URI", alias="resourceUri")
    search_name: Optional[StrictStr] = Field(default=None, description="Name of volume used for object search. Alphanumeric string, up to 64 characters including hyphen, period, colon.")
    snap_reserve: Optional[StrictInt] = Field(default=None, description="Amount of space to reserve for snapshots of this volume as a percentage of volume size.")
    snap_usage_compressed_bytes: Optional[StrictInt] = Field(default=None, description="Sum of compressed backup data in bytes stored in snapshots of this volume.")
    snap_usage_populated_bytes: Optional[StrictInt] = Field(default=None, description="Sum of backup data in bytes stored in snapshots of this volume without accounting for the sharing of data between snapshots.")
    snap_usage_uncompressed_bytes: Optional[StrictInt] = Field(default=None, description="Sum of uncompressed unique backup data in bytes stored in snapshots of this volume.")
    snap_warn_level: Optional[StrictInt] = Field(default=None, description="Threshold for available space as a percentage of volume size below which an alert is raised.")
    space_usage_level: Optional[StrictStr] = Field(default=None, description="Indicates space usage level based on warning level. Possible values: 'normal', 'warning', 'critical'.")
    srep_last_sync: Optional[StrictInt] = Field(default=None, description="Time when synchronously replicated volume was last synchronized.")
    srep_resync_percent: Optional[StrictInt] = Field(default=None, description="Percentage of resync progress for synchronously replicated volume.")
    thinly_provisioned: Optional[StrictBool] = Field(default=None, description="Allow volume to be advertised as thinly provisioned to initiators supporting thin provisioning. For such volumes, soft limit notification is set to initiators when the volume space usage crosses its volume_warn_level. Default is yes. This change takes effect only for new connections to the volume. Initiators must disconnect and reconnect for the new setting to be take effect at the initiator level consistently.")
    total_usage_bytes: Optional[StrictInt] = Field(default=None, description="Sum of compressed data and compressed backup data in bytes of this volume.")
    type: Optional[StrictStr] = Field(default=None, description="type")
    upstream_cache_pinned: Optional[StrictBool] = Field(default=None, description="This indicates whether the upstream volume is cache pinned or not.")
    usage_valid: Optional[StrictBool] = Field(default=None, description="This indicates whether usage information of volume and snapshots are valid or not.")
    vol_state: Optional[StrictStr] = Field(default=None, description="Status of the volume.  Possible values: 'online', 'offline', 'non_writable', 'read_only', 'login_only'.")
    vol_usage_compressed_bytes: Optional[StrictInt] = Field(default=None, description="Compressed data in bytes for this volume.")
    vol_usage_mapped_bytes: Optional[StrictInt] = Field(default=None, description="Mapped data in bytes for this volume.")
    vol_usage_uncompressed_bytes: Optional[StrictInt] = Field(default=None, description="Uncompressed data in bytes for this volume.")
    volcoll_creator_id: Optional[StrictStr] = Field(default=None, description="Originator id for the associated volume collection.")
    volcoll_creator_name: Optional[StrictStr] = Field(default=None, description="Originator name for the associated volume collection.")
    volume_creator_id: Optional[StrictStr] = Field(default=None, description="Originator id for the volume.")
    volume_creator_name: Optional[StrictStr] = Field(default=None, description="Originator name for the volume.")
    vpd_ieee0: Optional[StrictStr] = Field(default=None, description="The first 64 bits of the volume's EUI-64 identifier, encoded as a hexadecimal string. Plain string.")
    vpd_ieee1: Optional[StrictStr] = Field(default=None, description="The last 64 bits of the volume's EUI-64 identifier, encoded as a hexadecimal string. Plain string.")
    vpd_t10: Optional[StrictStr] = Field(default=None, description="The volume's T10 Vendor ID-based identifier. Plain string.")
    warn_level: Optional[StrictInt] = Field(default=None, description="Threshold for available space as a percentage of volume size below which an alert is raised. If this option is not specified, array default volume warn level setting is used to decide the warning level for this volume.")
    volume_export_details: Optional[NimbleVolumeExportDetails] = None
    __properties: ClassVar[List[str]] = ["base_snap_id", "base_snap_name", "clone", "dest_pool_id", "dest_pool_name", "folder_id", "folder_name", "id", "name", "online", "owned_by_group", "owned_by_group_id", "parent_vol_id", "parent_vol_name", "perfpolicy_id", "perfpolicy_name", "pool_id", "pool_name", "read_only", "replication_role", "secondary_serial_number", "serial_number", "size", "target_name", "volcoll_id", "volcoll_name", "access_control_records", "agent_type", "app_category", "app_uuid", "associated_links", "block_size", "cache_needed_for_pin", "cache_pinned", "cache_policy", "caching_enabled", "cksum_last_verified", "commonResourceAttributes", "consoleUri", "content_repl_errors_found", "creation_time", "customerId", "dedupe_enabled", "description", "encryption_cipher", "force", "full_name", "generation", "has_locked_snapshots", "inherit_acl", "is_mfa_protected", "iscsi_target_scope", "last_content_snap_br_cg_uid", "last_content_snap_br_gid", "last_content_snap_id", "last_modified", "last_snap", "limit", "limit_iops", "limit_mbps", "metadata", "move_aborting", "move_bytes_migrated", "move_bytes_remaining", "move_est_compl_time", "move_start_time", "multi_initiator", "needs_content_repl", "num_snaps", "offline_reason", "online_snaps", "perfpolicy_creator_id", "perfpolicy_creator_name", "pinned_cache_size", "pre_filter", "previously_deduped", "projected_num_snaps", "protection_type", "reserve", "resourceUri", "search_name", "snap_reserve", "snap_usage_compressed_bytes", "snap_usage_populated_bytes", "snap_usage_uncompressed_bytes", "snap_warn_level", "space_usage_level", "srep_last_sync", "srep_resync_percent", "thinly_provisioned", "total_usage_bytes", "type", "upstream_cache_pinned", "usage_valid", "vol_state", "vol_usage_compressed_bytes", "vol_usage_mapped_bytes", "vol_usage_uncompressed_bytes", "volcoll_creator_id", "volcoll_creator_name", "volume_creator_id", "volume_creator_name", "vpd_ieee0", "vpd_ieee1", "vpd_t10", "warn_level", "volume_export_details"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of NimbleVolumeDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in access_control_records (list)
        _items = []
        if self.access_control_records:
            for _item in self.access_control_records:
                if _item:
                    _items.append(_item.to_dict())
            _dict['access_control_records'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in associated_links (list)
        _items = []
        if self.associated_links:
            for _item in self.associated_links:
                if _item:
                    _items.append(_item.to_dict())
            _dict['associated_links'] = _items
        # override the default output from pydantic by calling `to_dict()` of common_resource_attributes
        if self.common_resource_attributes:
            _dict['commonResourceAttributes'] = self.common_resource_attributes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of last_snap
        if self.last_snap:
            _dict['last_snap'] = self.last_snap.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in metadata (list)
        _items = []
        if self.metadata:
            for _item in self.metadata:
                if _item:
                    _items.append(_item.to_dict())
            _dict['metadata'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in online_snaps (list)
        _items = []
        if self.online_snaps:
            for _item in self.online_snaps:
                if _item:
                    _items.append(_item.to_dict())
            _dict['online_snaps'] = _items
        # override the default output from pydantic by calling `to_dict()` of volume_export_details
        if self.volume_export_details:
            _dict['volume_export_details'] = self.volume_export_details.to_dict()
        # set to None if base_snap_id (nullable) is None
        # and model_fields_set contains the field
        if self.base_snap_id is None and "base_snap_id" in self.model_fields_set:
            _dict['base_snap_id'] = None

        # set to None if base_snap_name (nullable) is None
        # and model_fields_set contains the field
        if self.base_snap_name is None and "base_snap_name" in self.model_fields_set:
            _dict['base_snap_name'] = None

        # set to None if clone (nullable) is None
        # and model_fields_set contains the field
        if self.clone is None and "clone" in self.model_fields_set:
            _dict['clone'] = None

        # set to None if dest_pool_id (nullable) is None
        # and model_fields_set contains the field
        if self.dest_pool_id is None and "dest_pool_id" in self.model_fields_set:
            _dict['dest_pool_id'] = None

        # set to None if dest_pool_name (nullable) is None
        # and model_fields_set contains the field
        if self.dest_pool_name is None and "dest_pool_name" in self.model_fields_set:
            _dict['dest_pool_name'] = None

        # set to None if folder_id (nullable) is None
        # and model_fields_set contains the field
        if self.folder_id is None and "folder_id" in self.model_fields_set:
            _dict['folder_id'] = None

        # set to None if folder_name (nullable) is None
        # and model_fields_set contains the field
        if self.folder_name is None and "folder_name" in self.model_fields_set:
            _dict['folder_name'] = None

        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if online (nullable) is None
        # and model_fields_set contains the field
        if self.online is None and "online" in self.model_fields_set:
            _dict['online'] = None

        # set to None if owned_by_group (nullable) is None
        # and model_fields_set contains the field
        if self.owned_by_group is None and "owned_by_group" in self.model_fields_set:
            _dict['owned_by_group'] = None

        # set to None if owned_by_group_id (nullable) is None
        # and model_fields_set contains the field
        if self.owned_by_group_id is None and "owned_by_group_id" in self.model_fields_set:
            _dict['owned_by_group_id'] = None

        # set to None if parent_vol_id (nullable) is None
        # and model_fields_set contains the field
        if self.parent_vol_id is None and "parent_vol_id" in self.model_fields_set:
            _dict['parent_vol_id'] = None

        # set to None if parent_vol_name (nullable) is None
        # and model_fields_set contains the field
        if self.parent_vol_name is None and "parent_vol_name" in self.model_fields_set:
            _dict['parent_vol_name'] = None

        # set to None if perfpolicy_id (nullable) is None
        # and model_fields_set contains the field
        if self.perfpolicy_id is None and "perfpolicy_id" in self.model_fields_set:
            _dict['perfpolicy_id'] = None

        # set to None if perfpolicy_name (nullable) is None
        # and model_fields_set contains the field
        if self.perfpolicy_name is None and "perfpolicy_name" in self.model_fields_set:
            _dict['perfpolicy_name'] = None

        # set to None if pool_id (nullable) is None
        # and model_fields_set contains the field
        if self.pool_id is None and "pool_id" in self.model_fields_set:
            _dict['pool_id'] = None

        # set to None if pool_name (nullable) is None
        # and model_fields_set contains the field
        if self.pool_name is None and "pool_name" in self.model_fields_set:
            _dict['pool_name'] = None

        # set to None if read_only (nullable) is None
        # and model_fields_set contains the field
        if self.read_only is None and "read_only" in self.model_fields_set:
            _dict['read_only'] = None

        # set to None if replication_role (nullable) is None
        # and model_fields_set contains the field
        if self.replication_role is None and "replication_role" in self.model_fields_set:
            _dict['replication_role'] = None

        # set to None if secondary_serial_number (nullable) is None
        # and model_fields_set contains the field
        if self.secondary_serial_number is None and "secondary_serial_number" in self.model_fields_set:
            _dict['secondary_serial_number'] = None

        # set to None if serial_number (nullable) is None
        # and model_fields_set contains the field
        if self.serial_number is None and "serial_number" in self.model_fields_set:
            _dict['serial_number'] = None

        # set to None if size (nullable) is None
        # and model_fields_set contains the field
        if self.size is None and "size" in self.model_fields_set:
            _dict['size'] = None

        # set to None if target_name (nullable) is None
        # and model_fields_set contains the field
        if self.target_name is None and "target_name" in self.model_fields_set:
            _dict['target_name'] = None

        # set to None if volcoll_id (nullable) is None
        # and model_fields_set contains the field
        if self.volcoll_id is None and "volcoll_id" in self.model_fields_set:
            _dict['volcoll_id'] = None

        # set to None if volcoll_name (nullable) is None
        # and model_fields_set contains the field
        if self.volcoll_name is None and "volcoll_name" in self.model_fields_set:
            _dict['volcoll_name'] = None

        # set to None if access_control_records (nullable) is None
        # and model_fields_set contains the field
        if self.access_control_records is None and "access_control_records" in self.model_fields_set:
            _dict['access_control_records'] = None

        # set to None if agent_type (nullable) is None
        # and model_fields_set contains the field
        if self.agent_type is None and "agent_type" in self.model_fields_set:
            _dict['agent_type'] = None

        # set to None if app_category (nullable) is None
        # and model_fields_set contains the field
        if self.app_category is None and "app_category" in self.model_fields_set:
            _dict['app_category'] = None

        # set to None if app_uuid (nullable) is None
        # and model_fields_set contains the field
        if self.app_uuid is None and "app_uuid" in self.model_fields_set:
            _dict['app_uuid'] = None

        # set to None if block_size (nullable) is None
        # and model_fields_set contains the field
        if self.block_size is None and "block_size" in self.model_fields_set:
            _dict['block_size'] = None

        # set to None if cache_needed_for_pin (nullable) is None
        # and model_fields_set contains the field
        if self.cache_needed_for_pin is None and "cache_needed_for_pin" in self.model_fields_set:
            _dict['cache_needed_for_pin'] = None

        # set to None if cache_pinned (nullable) is None
        # and model_fields_set contains the field
        if self.cache_pinned is None and "cache_pinned" in self.model_fields_set:
            _dict['cache_pinned'] = None

        # set to None if cache_policy (nullable) is None
        # and model_fields_set contains the field
        if self.cache_policy is None and "cache_policy" in self.model_fields_set:
            _dict['cache_policy'] = None

        # set to None if caching_enabled (nullable) is None
        # and model_fields_set contains the field
        if self.caching_enabled is None and "caching_enabled" in self.model_fields_set:
            _dict['caching_enabled'] = None

        # set to None if cksum_last_verified (nullable) is None
        # and model_fields_set contains the field
        if self.cksum_last_verified is None and "cksum_last_verified" in self.model_fields_set:
            _dict['cksum_last_verified'] = None

        # set to None if common_resource_attributes (nullable) is None
        # and model_fields_set contains the field
        if self.common_resource_attributes is None and "common_resource_attributes" in self.model_fields_set:
            _dict['commonResourceAttributes'] = None

        # set to None if console_uri (nullable) is None
        # and model_fields_set contains the field
        if self.console_uri is None and "console_uri" in self.model_fields_set:
            _dict['consoleUri'] = None

        # set to None if content_repl_errors_found (nullable) is None
        # and model_fields_set contains the field
        if self.content_repl_errors_found is None and "content_repl_errors_found" in self.model_fields_set:
            _dict['content_repl_errors_found'] = None

        # set to None if creation_time (nullable) is None
        # and model_fields_set contains the field
        if self.creation_time is None and "creation_time" in self.model_fields_set:
            _dict['creation_time'] = None

        # set to None if customer_id (nullable) is None
        # and model_fields_set contains the field
        if self.customer_id is None and "customer_id" in self.model_fields_set:
            _dict['customerId'] = None

        # set to None if dedupe_enabled (nullable) is None
        # and model_fields_set contains the field
        if self.dedupe_enabled is None and "dedupe_enabled" in self.model_fields_set:
            _dict['dedupe_enabled'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if encryption_cipher (nullable) is None
        # and model_fields_set contains the field
        if self.encryption_cipher is None and "encryption_cipher" in self.model_fields_set:
            _dict['encryption_cipher'] = None

        # set to None if force (nullable) is None
        # and model_fields_set contains the field
        if self.force is None and "force" in self.model_fields_set:
            _dict['force'] = None

        # set to None if full_name (nullable) is None
        # and model_fields_set contains the field
        if self.full_name is None and "full_name" in self.model_fields_set:
            _dict['full_name'] = None

        # set to None if generation (nullable) is None
        # and model_fields_set contains the field
        if self.generation is None and "generation" in self.model_fields_set:
            _dict['generation'] = None

        # set to None if has_locked_snapshots (nullable) is None
        # and model_fields_set contains the field
        if self.has_locked_snapshots is None and "has_locked_snapshots" in self.model_fields_set:
            _dict['has_locked_snapshots'] = None

        # set to None if inherit_acl (nullable) is None
        # and model_fields_set contains the field
        if self.inherit_acl is None and "inherit_acl" in self.model_fields_set:
            _dict['inherit_acl'] = None

        # set to None if is_mfa_protected (nullable) is None
        # and model_fields_set contains the field
        if self.is_mfa_protected is None and "is_mfa_protected" in self.model_fields_set:
            _dict['is_mfa_protected'] = None

        # set to None if iscsi_target_scope (nullable) is None
        # and model_fields_set contains the field
        if self.iscsi_target_scope is None and "iscsi_target_scope" in self.model_fields_set:
            _dict['iscsi_target_scope'] = None

        # set to None if last_content_snap_br_cg_uid (nullable) is None
        # and model_fields_set contains the field
        if self.last_content_snap_br_cg_uid is None and "last_content_snap_br_cg_uid" in self.model_fields_set:
            _dict['last_content_snap_br_cg_uid'] = None

        # set to None if last_content_snap_br_gid (nullable) is None
        # and model_fields_set contains the field
        if self.last_content_snap_br_gid is None and "last_content_snap_br_gid" in self.model_fields_set:
            _dict['last_content_snap_br_gid'] = None

        # set to None if last_content_snap_id (nullable) is None
        # and model_fields_set contains the field
        if self.last_content_snap_id is None and "last_content_snap_id" in self.model_fields_set:
            _dict['last_content_snap_id'] = None

        # set to None if last_modified (nullable) is None
        # and model_fields_set contains the field
        if self.last_modified is None and "last_modified" in self.model_fields_set:
            _dict['last_modified'] = None

        # set to None if last_snap (nullable) is None
        # and model_fields_set contains the field
        if self.last_snap is None and "last_snap" in self.model_fields_set:
            _dict['last_snap'] = None

        # set to None if limit (nullable) is None
        # and model_fields_set contains the field
        if self.limit is None and "limit" in self.model_fields_set:
            _dict['limit'] = None

        # set to None if limit_iops (nullable) is None
        # and model_fields_set contains the field
        if self.limit_iops is None and "limit_iops" in self.model_fields_set:
            _dict['limit_iops'] = None

        # set to None if limit_mbps (nullable) is None
        # and model_fields_set contains the field
        if self.limit_mbps is None and "limit_mbps" in self.model_fields_set:
            _dict['limit_mbps'] = None

        # set to None if metadata (nullable) is None
        # and model_fields_set contains the field
        if self.metadata is None and "metadata" in self.model_fields_set:
            _dict['metadata'] = None

        # set to None if move_aborting (nullable) is None
        # and model_fields_set contains the field
        if self.move_aborting is None and "move_aborting" in self.model_fields_set:
            _dict['move_aborting'] = None

        # set to None if move_bytes_migrated (nullable) is None
        # and model_fields_set contains the field
        if self.move_bytes_migrated is None and "move_bytes_migrated" in self.model_fields_set:
            _dict['move_bytes_migrated'] = None

        # set to None if move_bytes_remaining (nullable) is None
        # and model_fields_set contains the field
        if self.move_bytes_remaining is None and "move_bytes_remaining" in self.model_fields_set:
            _dict['move_bytes_remaining'] = None

        # set to None if move_est_compl_time (nullable) is None
        # and model_fields_set contains the field
        if self.move_est_compl_time is None and "move_est_compl_time" in self.model_fields_set:
            _dict['move_est_compl_time'] = None

        # set to None if move_start_time (nullable) is None
        # and model_fields_set contains the field
        if self.move_start_time is None and "move_start_time" in self.model_fields_set:
            _dict['move_start_time'] = None

        # set to None if multi_initiator (nullable) is None
        # and model_fields_set contains the field
        if self.multi_initiator is None and "multi_initiator" in self.model_fields_set:
            _dict['multi_initiator'] = None

        # set to None if needs_content_repl (nullable) is None
        # and model_fields_set contains the field
        if self.needs_content_repl is None and "needs_content_repl" in self.model_fields_set:
            _dict['needs_content_repl'] = None

        # set to None if num_snaps (nullable) is None
        # and model_fields_set contains the field
        if self.num_snaps is None and "num_snaps" in self.model_fields_set:
            _dict['num_snaps'] = None

        # set to None if offline_reason (nullable) is None
        # and model_fields_set contains the field
        if self.offline_reason is None and "offline_reason" in self.model_fields_set:
            _dict['offline_reason'] = None

        # set to None if online_snaps (nullable) is None
        # and model_fields_set contains the field
        if self.online_snaps is None and "online_snaps" in self.model_fields_set:
            _dict['online_snaps'] = None

        # set to None if perfpolicy_creator_id (nullable) is None
        # and model_fields_set contains the field
        if self.perfpolicy_creator_id is None and "perfpolicy_creator_id" in self.model_fields_set:
            _dict['perfpolicy_creator_id'] = None

        # set to None if perfpolicy_creator_name (nullable) is None
        # and model_fields_set contains the field
        if self.perfpolicy_creator_name is None and "perfpolicy_creator_name" in self.model_fields_set:
            _dict['perfpolicy_creator_name'] = None

        # set to None if pinned_cache_size (nullable) is None
        # and model_fields_set contains the field
        if self.pinned_cache_size is None and "pinned_cache_size" in self.model_fields_set:
            _dict['pinned_cache_size'] = None

        # set to None if pre_filter (nullable) is None
        # and model_fields_set contains the field
        if self.pre_filter is None and "pre_filter" in self.model_fields_set:
            _dict['pre_filter'] = None

        # set to None if previously_deduped (nullable) is None
        # and model_fields_set contains the field
        if self.previously_deduped is None and "previously_deduped" in self.model_fields_set:
            _dict['previously_deduped'] = None

        # set to None if projected_num_snaps (nullable) is None
        # and model_fields_set contains the field
        if self.projected_num_snaps is None and "projected_num_snaps" in self.model_fields_set:
            _dict['projected_num_snaps'] = None

        # set to None if protection_type (nullable) is None
        # and model_fields_set contains the field
        if self.protection_type is None and "protection_type" in self.model_fields_set:
            _dict['protection_type'] = None

        # set to None if reserve (nullable) is None
        # and model_fields_set contains the field
        if self.reserve is None and "reserve" in self.model_fields_set:
            _dict['reserve'] = None

        # set to None if resource_uri (nullable) is None
        # and model_fields_set contains the field
        if self.resource_uri is None and "resource_uri" in self.model_fields_set:
            _dict['resourceUri'] = None

        # set to None if search_name (nullable) is None
        # and model_fields_set contains the field
        if self.search_name is None and "search_name" in self.model_fields_set:
            _dict['search_name'] = None

        # set to None if snap_reserve (nullable) is None
        # and model_fields_set contains the field
        if self.snap_reserve is None and "snap_reserve" in self.model_fields_set:
            _dict['snap_reserve'] = None

        # set to None if snap_usage_compressed_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.snap_usage_compressed_bytes is None and "snap_usage_compressed_bytes" in self.model_fields_set:
            _dict['snap_usage_compressed_bytes'] = None

        # set to None if snap_usage_populated_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.snap_usage_populated_bytes is None and "snap_usage_populated_bytes" in self.model_fields_set:
            _dict['snap_usage_populated_bytes'] = None

        # set to None if snap_usage_uncompressed_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.snap_usage_uncompressed_bytes is None and "snap_usage_uncompressed_bytes" in self.model_fields_set:
            _dict['snap_usage_uncompressed_bytes'] = None

        # set to None if snap_warn_level (nullable) is None
        # and model_fields_set contains the field
        if self.snap_warn_level is None and "snap_warn_level" in self.model_fields_set:
            _dict['snap_warn_level'] = None

        # set to None if srep_last_sync (nullable) is None
        # and model_fields_set contains the field
        if self.srep_last_sync is None and "srep_last_sync" in self.model_fields_set:
            _dict['srep_last_sync'] = None

        # set to None if srep_resync_percent (nullable) is None
        # and model_fields_set contains the field
        if self.srep_resync_percent is None and "srep_resync_percent" in self.model_fields_set:
            _dict['srep_resync_percent'] = None

        # set to None if thinly_provisioned (nullable) is None
        # and model_fields_set contains the field
        if self.thinly_provisioned is None and "thinly_provisioned" in self.model_fields_set:
            _dict['thinly_provisioned'] = None

        # set to None if total_usage_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.total_usage_bytes is None and "total_usage_bytes" in self.model_fields_set:
            _dict['total_usage_bytes'] = None

        # set to None if type (nullable) is None
        # and model_fields_set contains the field
        if self.type is None and "type" in self.model_fields_set:
            _dict['type'] = None

        # set to None if upstream_cache_pinned (nullable) is None
        # and model_fields_set contains the field
        if self.upstream_cache_pinned is None and "upstream_cache_pinned" in self.model_fields_set:
            _dict['upstream_cache_pinned'] = None

        # set to None if usage_valid (nullable) is None
        # and model_fields_set contains the field
        if self.usage_valid is None and "usage_valid" in self.model_fields_set:
            _dict['usage_valid'] = None

        # set to None if vol_state (nullable) is None
        # and model_fields_set contains the field
        if self.vol_state is None and "vol_state" in self.model_fields_set:
            _dict['vol_state'] = None

        # set to None if vol_usage_compressed_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.vol_usage_compressed_bytes is None and "vol_usage_compressed_bytes" in self.model_fields_set:
            _dict['vol_usage_compressed_bytes'] = None

        # set to None if vol_usage_mapped_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.vol_usage_mapped_bytes is None and "vol_usage_mapped_bytes" in self.model_fields_set:
            _dict['vol_usage_mapped_bytes'] = None

        # set to None if vol_usage_uncompressed_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.vol_usage_uncompressed_bytes is None and "vol_usage_uncompressed_bytes" in self.model_fields_set:
            _dict['vol_usage_uncompressed_bytes'] = None

        # set to None if volcoll_creator_id (nullable) is None
        # and model_fields_set contains the field
        if self.volcoll_creator_id is None and "volcoll_creator_id" in self.model_fields_set:
            _dict['volcoll_creator_id'] = None

        # set to None if volcoll_creator_name (nullable) is None
        # and model_fields_set contains the field
        if self.volcoll_creator_name is None and "volcoll_creator_name" in self.model_fields_set:
            _dict['volcoll_creator_name'] = None

        # set to None if volume_creator_id (nullable) is None
        # and model_fields_set contains the field
        if self.volume_creator_id is None and "volume_creator_id" in self.model_fields_set:
            _dict['volume_creator_id'] = None

        # set to None if volume_creator_name (nullable) is None
        # and model_fields_set contains the field
        if self.volume_creator_name is None and "volume_creator_name" in self.model_fields_set:
            _dict['volume_creator_name'] = None

        # set to None if vpd_ieee0 (nullable) is None
        # and model_fields_set contains the field
        if self.vpd_ieee0 is None and "vpd_ieee0" in self.model_fields_set:
            _dict['vpd_ieee0'] = None

        # set to None if vpd_ieee1 (nullable) is None
        # and model_fields_set contains the field
        if self.vpd_ieee1 is None and "vpd_ieee1" in self.model_fields_set:
            _dict['vpd_ieee1'] = None

        # set to None if vpd_t10 (nullable) is None
        # and model_fields_set contains the field
        if self.vpd_t10 is None and "vpd_t10" in self.model_fields_set:
            _dict['vpd_t10'] = None

        # set to None if warn_level (nullable) is None
        # and model_fields_set contains the field
        if self.warn_level is None and "warn_level" in self.model_fields_set:
            _dict['warn_level'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of NimbleVolumeDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "base_snap_id": obj.get("base_snap_id"),
            "base_snap_name": obj.get("base_snap_name"),
            "clone": obj.get("clone"),
            "dest_pool_id": obj.get("dest_pool_id"),
            "dest_pool_name": obj.get("dest_pool_name"),
            "folder_id": obj.get("folder_id"),
            "folder_name": obj.get("folder_name"),
            "id": obj.get("id"),
            "name": obj.get("name"),
            "online": obj.get("online"),
            "owned_by_group": obj.get("owned_by_group"),
            "owned_by_group_id": obj.get("owned_by_group_id"),
            "parent_vol_id": obj.get("parent_vol_id"),
            "parent_vol_name": obj.get("parent_vol_name"),
            "perfpolicy_id": obj.get("perfpolicy_id"),
            "perfpolicy_name": obj.get("perfpolicy_name"),
            "pool_id": obj.get("pool_id"),
            "pool_name": obj.get("pool_name"),
            "read_only": obj.get("read_only"),
            "replication_role": obj.get("replication_role"),
            "secondary_serial_number": obj.get("secondary_serial_number"),
            "serial_number": obj.get("serial_number"),
            "size": obj.get("size"),
            "target_name": obj.get("target_name"),
            "volcoll_id": obj.get("volcoll_id"),
            "volcoll_name": obj.get("volcoll_name"),
            "access_control_records": [AccessControlRecord.from_dict(_item) for _item in obj["access_control_records"]] if obj.get("access_control_records") is not None else None,
            "agent_type": obj.get("agent_type"),
            "app_category": obj.get("app_category"),
            "app_uuid": obj.get("app_uuid"),
            "associated_links": [AssociatedLinksInner.from_dict(_item) for _item in obj["associated_links"]] if obj.get("associated_links") is not None else None,
            "block_size": obj.get("block_size"),
            "cache_needed_for_pin": obj.get("cache_needed_for_pin"),
            "cache_pinned": obj.get("cache_pinned"),
            "cache_policy": obj.get("cache_policy"),
            "caching_enabled": obj.get("caching_enabled"),
            "cksum_last_verified": obj.get("cksum_last_verified"),
            "commonResourceAttributes": NimbleCommonResourceAttributes.from_dict(obj["commonResourceAttributes"]) if obj.get("commonResourceAttributes") is not None else None,
            "consoleUri": obj.get("consoleUri"),
            "content_repl_errors_found": obj.get("content_repl_errors_found"),
            "creation_time": obj.get("creation_time"),
            "customerId": obj.get("customerId"),
            "dedupe_enabled": obj.get("dedupe_enabled"),
            "description": obj.get("description"),
            "encryption_cipher": obj.get("encryption_cipher"),
            "force": obj.get("force"),
            "full_name": obj.get("full_name"),
            "generation": obj.get("generation"),
            "has_locked_snapshots": obj.get("has_locked_snapshots"),
            "inherit_acl": obj.get("inherit_acl"),
            "is_mfa_protected": obj.get("is_mfa_protected"),
            "iscsi_target_scope": obj.get("iscsi_target_scope"),
            "last_content_snap_br_cg_uid": obj.get("last_content_snap_br_cg_uid"),
            "last_content_snap_br_gid": obj.get("last_content_snap_br_gid"),
            "last_content_snap_id": obj.get("last_content_snap_id"),
            "last_modified": obj.get("last_modified"),
            "last_snap": SnapSummary.from_dict(obj["last_snap"]) if obj.get("last_snap") is not None else None,
            "limit": obj.get("limit"),
            "limit_iops": obj.get("limit_iops"),
            "limit_mbps": obj.get("limit_mbps"),
            "metadata": [KeyValue.from_dict(_item) for _item in obj["metadata"]] if obj.get("metadata") is not None else None,
            "move_aborting": obj.get("move_aborting"),
            "move_bytes_migrated": obj.get("move_bytes_migrated"),
            "move_bytes_remaining": obj.get("move_bytes_remaining"),
            "move_est_compl_time": obj.get("move_est_compl_time"),
            "move_start_time": obj.get("move_start_time"),
            "multi_initiator": obj.get("multi_initiator"),
            "needs_content_repl": obj.get("needs_content_repl"),
            "num_snaps": obj.get("num_snaps"),
            "offline_reason": obj.get("offline_reason"),
            "online_snaps": [SnapshotFromVolume.from_dict(_item) for _item in obj["online_snaps"]] if obj.get("online_snaps") is not None else None,
            "perfpolicy_creator_id": obj.get("perfpolicy_creator_id"),
            "perfpolicy_creator_name": obj.get("perfpolicy_creator_name"),
            "pinned_cache_size": obj.get("pinned_cache_size"),
            "pre_filter": obj.get("pre_filter"),
            "previously_deduped": obj.get("previously_deduped"),
            "projected_num_snaps": obj.get("projected_num_snaps"),
            "protection_type": obj.get("protection_type"),
            "reserve": obj.get("reserve"),
            "resourceUri": obj.get("resourceUri"),
            "search_name": obj.get("search_name"),
            "snap_reserve": obj.get("snap_reserve"),
            "snap_usage_compressed_bytes": obj.get("snap_usage_compressed_bytes"),
            "snap_usage_populated_bytes": obj.get("snap_usage_populated_bytes"),
            "snap_usage_uncompressed_bytes": obj.get("snap_usage_uncompressed_bytes"),
            "snap_warn_level": obj.get("snap_warn_level"),
            "space_usage_level": obj.get("space_usage_level"),
            "srep_last_sync": obj.get("srep_last_sync"),
            "srep_resync_percent": obj.get("srep_resync_percent"),
            "thinly_provisioned": obj.get("thinly_provisioned"),
            "total_usage_bytes": obj.get("total_usage_bytes"),
            "type": obj.get("type"),
            "upstream_cache_pinned": obj.get("upstream_cache_pinned"),
            "usage_valid": obj.get("usage_valid"),
            "vol_state": obj.get("vol_state"),
            "vol_usage_compressed_bytes": obj.get("vol_usage_compressed_bytes"),
            "vol_usage_mapped_bytes": obj.get("vol_usage_mapped_bytes"),
            "vol_usage_uncompressed_bytes": obj.get("vol_usage_uncompressed_bytes"),
            "volcoll_creator_id": obj.get("volcoll_creator_id"),
            "volcoll_creator_name": obj.get("volcoll_creator_name"),
            "volume_creator_id": obj.get("volume_creator_id"),
            "volume_creator_name": obj.get("volume_creator_name"),
            "vpd_ieee0": obj.get("vpd_ieee0"),
            "vpd_ieee1": obj.get("vpd_ieee1"),
            "vpd_t10": obj.get("vpd_t10"),
            "warn_level": obj.get("warn_level"),
            "volume_export_details": NimbleVolumeExportDetails.from_dict(obj["volume_export_details"]) if obj.get("volume_export_details") is not None else None
        })
        return _obj


