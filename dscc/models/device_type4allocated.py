# coding: utf-8

"""
    Data Services Cloud Console API

    Data Services Cloud Console API

    The version of the OpenAPI document: 1.6.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Optional, Union
from dscc.models.device_type4allocated_cpgs_private_snap import DeviceType4allocatedCpgsPrivateSnap
from dscc.models.device_type4private import DeviceType4private
from typing import Optional, Set
from typing_extensions import Self

class DeviceType4allocated(BaseModel):
    """
    DeviceType4allocated
    """ # noqa: E501
    cpgs: Optional[Union[StrictFloat, StrictInt]] = None
    cpgs_free: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="cpgsFree")
    cpgs_private: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="cpgsPrivate")
    cpgs_private_base: Optional[DeviceType4private] = Field(default=None, alias="cpgsPrivateBase")
    cpgs_private_snap: Optional[DeviceType4allocatedCpgsPrivateSnap] = Field(default=None, alias="cpgsPrivateSnap")
    cpgs_shared: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="cpgsShared")
    legacy_volumes: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="legacyVolumes")
    legacy_volumes_snap: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="legacyVolumesSnap")
    legacy_volumes_user: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="legacyVolumesUser")
    system: Optional[Union[StrictFloat, StrictInt]] = None
    system_admin: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="systemAdmin")
    system_internal: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="systemInternal")
    system_spare: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="systemSpare")
    system_spare_unused: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="systemSpareUnused")
    system_spare_used: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="systemSpareUsed")
    total: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Total allocated percentage")
    unmapped: Optional[Union[StrictFloat, StrictInt]] = None
    __properties: ClassVar[List[str]] = ["cpgs", "cpgsFree", "cpgsPrivate", "cpgsPrivateBase", "cpgsPrivateSnap", "cpgsShared", "legacyVolumes", "legacyVolumesSnap", "legacyVolumesUser", "system", "systemAdmin", "systemInternal", "systemSpare", "systemSpareUnused", "systemSpareUsed", "total", "unmapped"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DeviceType4allocated from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of cpgs_private_base
        if self.cpgs_private_base:
            _dict['cpgsPrivateBase'] = self.cpgs_private_base.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cpgs_private_snap
        if self.cpgs_private_snap:
            _dict['cpgsPrivateSnap'] = self.cpgs_private_snap.to_dict()
        # set to None if cpgs (nullable) is None
        # and model_fields_set contains the field
        if self.cpgs is None and "cpgs" in self.model_fields_set:
            _dict['cpgs'] = None

        # set to None if cpgs_free (nullable) is None
        # and model_fields_set contains the field
        if self.cpgs_free is None and "cpgs_free" in self.model_fields_set:
            _dict['cpgsFree'] = None

        # set to None if cpgs_private (nullable) is None
        # and model_fields_set contains the field
        if self.cpgs_private is None and "cpgs_private" in self.model_fields_set:
            _dict['cpgsPrivate'] = None

        # set to None if cpgs_private_base (nullable) is None
        # and model_fields_set contains the field
        if self.cpgs_private_base is None and "cpgs_private_base" in self.model_fields_set:
            _dict['cpgsPrivateBase'] = None

        # set to None if cpgs_private_snap (nullable) is None
        # and model_fields_set contains the field
        if self.cpgs_private_snap is None and "cpgs_private_snap" in self.model_fields_set:
            _dict['cpgsPrivateSnap'] = None

        # set to None if cpgs_shared (nullable) is None
        # and model_fields_set contains the field
        if self.cpgs_shared is None and "cpgs_shared" in self.model_fields_set:
            _dict['cpgsShared'] = None

        # set to None if legacy_volumes (nullable) is None
        # and model_fields_set contains the field
        if self.legacy_volumes is None and "legacy_volumes" in self.model_fields_set:
            _dict['legacyVolumes'] = None

        # set to None if legacy_volumes_snap (nullable) is None
        # and model_fields_set contains the field
        if self.legacy_volumes_snap is None and "legacy_volumes_snap" in self.model_fields_set:
            _dict['legacyVolumesSnap'] = None

        # set to None if legacy_volumes_user (nullable) is None
        # and model_fields_set contains the field
        if self.legacy_volumes_user is None and "legacy_volumes_user" in self.model_fields_set:
            _dict['legacyVolumesUser'] = None

        # set to None if system (nullable) is None
        # and model_fields_set contains the field
        if self.system is None and "system" in self.model_fields_set:
            _dict['system'] = None

        # set to None if system_admin (nullable) is None
        # and model_fields_set contains the field
        if self.system_admin is None and "system_admin" in self.model_fields_set:
            _dict['systemAdmin'] = None

        # set to None if system_internal (nullable) is None
        # and model_fields_set contains the field
        if self.system_internal is None and "system_internal" in self.model_fields_set:
            _dict['systemInternal'] = None

        # set to None if system_spare (nullable) is None
        # and model_fields_set contains the field
        if self.system_spare is None and "system_spare" in self.model_fields_set:
            _dict['systemSpare'] = None

        # set to None if system_spare_unused (nullable) is None
        # and model_fields_set contains the field
        if self.system_spare_unused is None and "system_spare_unused" in self.model_fields_set:
            _dict['systemSpareUnused'] = None

        # set to None if system_spare_used (nullable) is None
        # and model_fields_set contains the field
        if self.system_spare_used is None and "system_spare_used" in self.model_fields_set:
            _dict['systemSpareUsed'] = None

        # set to None if total (nullable) is None
        # and model_fields_set contains the field
        if self.total is None and "total" in self.model_fields_set:
            _dict['total'] = None

        # set to None if unmapped (nullable) is None
        # and model_fields_set contains the field
        if self.unmapped is None and "unmapped" in self.model_fields_set:
            _dict['unmapped'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DeviceType4allocated from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "cpgs": obj.get("cpgs"),
            "cpgsFree": obj.get("cpgsFree"),
            "cpgsPrivate": obj.get("cpgsPrivate"),
            "cpgsPrivateBase": DeviceType4private.from_dict(obj["cpgsPrivateBase"]) if obj.get("cpgsPrivateBase") is not None else None,
            "cpgsPrivateSnap": DeviceType4allocatedCpgsPrivateSnap.from_dict(obj["cpgsPrivateSnap"]) if obj.get("cpgsPrivateSnap") is not None else None,
            "cpgsShared": obj.get("cpgsShared"),
            "legacyVolumes": obj.get("legacyVolumes"),
            "legacyVolumesSnap": obj.get("legacyVolumesSnap"),
            "legacyVolumesUser": obj.get("legacyVolumesUser"),
            "system": obj.get("system"),
            "systemAdmin": obj.get("systemAdmin"),
            "systemInternal": obj.get("systemInternal"),
            "systemSpare": obj.get("systemSpare"),
            "systemSpareUnused": obj.get("systemSpareUnused"),
            "systemSpareUsed": obj.get("systemSpareUsed"),
            "total": obj.get("total"),
            "unmapped": obj.get("unmapped")
        })
        return _obj


