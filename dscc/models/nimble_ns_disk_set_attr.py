# coding: utf-8

"""
    Data Services Cloud Console API

    Data Services Cloud Console API

    The version of the OpenAPI document: 1.6.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class NimbleNsDiskSetAttr(BaseModel):
    """
    NimbleNsDiskSetAttr
    """ # noqa: E501
    ave_mb_ps: Optional[StrictInt] = Field(default=None, description="Average evacuation speed in MB/s; valid only when sw_state is evacuating, ie. evacuation is underway.")
    ave_segment_ps: Optional[StrictInt] = Field(default=None, description="Average evacuation speed in segments/sec; valid only when sw_state is evacuating, ie. evacuation is underway.")
    ave_ttc: Optional[StrictInt] = Field(default=None, description="Average time to complete in seconds; valid only when sw_state is evacuating, ie. evacuation is underway.")
    driveset: Optional[StrictInt] = Field(default=None, description="Driveset index for this shelf.")
    is_capacity_valid: Optional[StrictBool] = Field(default=None, description="Is the capacity fields in this data struct valid.")
    is_flash_shelf: Optional[StrictBool] = Field(default=None, description="Is this a all-flash-shelf.")
    pause_state: Optional[StrictInt] = Field(default=None, description="State of evacuation, paused or in-progress; valid only when sw_state is evacuating, ie. evacuation is underway.")
    pct_completion: Optional[StrictInt] = Field(default=None, description="Evacuation percent completion; valid only when sw_state is evacuating, ie. evacuation is underway.")
    raw_cache_capacity: Optional[StrictInt] = Field(default=None, description="Raw cache capacity for this shelf.")
    raw_capacity: Optional[StrictInt] = Field(default=None, description="Hdd raw capacity for this shelf.")
    sw_state: Optional[StrictStr] = Field(default=None, description="Software state. Possible values:'available', 'online', 'foreign', 'unknown'.")
    usable_cache_capacity: Optional[StrictInt] = Field(default=None, description="Estimated usable cache capacity for this shelf.")
    usable_capacity: Optional[StrictInt] = Field(default=None, description="Estimated usable capacity for this shelf.")
    __properties: ClassVar[List[str]] = ["ave_mb_ps", "ave_segment_ps", "ave_ttc", "driveset", "is_capacity_valid", "is_flash_shelf", "pause_state", "pct_completion", "raw_cache_capacity", "raw_capacity", "sw_state", "usable_cache_capacity", "usable_capacity"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of NimbleNsDiskSetAttr from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if ave_mb_ps (nullable) is None
        # and model_fields_set contains the field
        if self.ave_mb_ps is None and "ave_mb_ps" in self.model_fields_set:
            _dict['ave_mb_ps'] = None

        # set to None if ave_segment_ps (nullable) is None
        # and model_fields_set contains the field
        if self.ave_segment_ps is None and "ave_segment_ps" in self.model_fields_set:
            _dict['ave_segment_ps'] = None

        # set to None if ave_ttc (nullable) is None
        # and model_fields_set contains the field
        if self.ave_ttc is None and "ave_ttc" in self.model_fields_set:
            _dict['ave_ttc'] = None

        # set to None if driveset (nullable) is None
        # and model_fields_set contains the field
        if self.driveset is None and "driveset" in self.model_fields_set:
            _dict['driveset'] = None

        # set to None if is_capacity_valid (nullable) is None
        # and model_fields_set contains the field
        if self.is_capacity_valid is None and "is_capacity_valid" in self.model_fields_set:
            _dict['is_capacity_valid'] = None

        # set to None if is_flash_shelf (nullable) is None
        # and model_fields_set contains the field
        if self.is_flash_shelf is None and "is_flash_shelf" in self.model_fields_set:
            _dict['is_flash_shelf'] = None

        # set to None if pause_state (nullable) is None
        # and model_fields_set contains the field
        if self.pause_state is None and "pause_state" in self.model_fields_set:
            _dict['pause_state'] = None

        # set to None if pct_completion (nullable) is None
        # and model_fields_set contains the field
        if self.pct_completion is None and "pct_completion" in self.model_fields_set:
            _dict['pct_completion'] = None

        # set to None if raw_cache_capacity (nullable) is None
        # and model_fields_set contains the field
        if self.raw_cache_capacity is None and "raw_cache_capacity" in self.model_fields_set:
            _dict['raw_cache_capacity'] = None

        # set to None if raw_capacity (nullable) is None
        # and model_fields_set contains the field
        if self.raw_capacity is None and "raw_capacity" in self.model_fields_set:
            _dict['raw_capacity'] = None

        # set to None if sw_state (nullable) is None
        # and model_fields_set contains the field
        if self.sw_state is None and "sw_state" in self.model_fields_set:
            _dict['sw_state'] = None

        # set to None if usable_cache_capacity (nullable) is None
        # and model_fields_set contains the field
        if self.usable_cache_capacity is None and "usable_cache_capacity" in self.model_fields_set:
            _dict['usable_cache_capacity'] = None

        # set to None if usable_capacity (nullable) is None
        # and model_fields_set contains the field
        if self.usable_capacity is None and "usable_capacity" in self.model_fields_set:
            _dict['usable_capacity'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of NimbleNsDiskSetAttr from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ave_mb_ps": obj.get("ave_mb_ps"),
            "ave_segment_ps": obj.get("ave_segment_ps"),
            "ave_ttc": obj.get("ave_ttc"),
            "driveset": obj.get("driveset"),
            "is_capacity_valid": obj.get("is_capacity_valid"),
            "is_flash_shelf": obj.get("is_flash_shelf"),
            "pause_state": obj.get("pause_state"),
            "pct_completion": obj.get("pct_completion"),
            "raw_cache_capacity": obj.get("raw_cache_capacity"),
            "raw_capacity": obj.get("raw_capacity"),
            "sw_state": obj.get("sw_state"),
            "usable_cache_capacity": obj.get("usable_cache_capacity"),
            "usable_capacity": obj.get("usable_capacity")
        })
        return _obj


