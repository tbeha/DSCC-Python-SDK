# coding: utf-8

"""
    Data Services Cloud Console API

    Data Services Cloud Console API

    The version of the OpenAPI document: 1.6.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class DeviceType4AppSetQoSConfig(BaseModel):
    """
    DeviceType4AppSetQoSConfig
    """ # noqa: E501
    bandwidth_max_limit_ki_b: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Bandwidth Maximum Limit in KiB", alias="bandwidthMaxLimitKiB")
    bw_guarantee_tb: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Bandwidth Guarantee Limit per Tb in KiB", alias="bwGuaranteeTb")
    bw_limit_tb: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Bandwidth Maximum Limit per Tb in KiB", alias="bwLimitTb")
    displayname: Optional[StrictStr] = Field(default=None, description="QoS Config Display name")
    domain: Optional[StrictStr] = Field(default=None, description="Domain Name")
    enable: Optional[StrictBool] = Field(default=None, description="Enable of QoS Configuration")
    enable_sr_alert: Optional[StrictBool] = Field(default=None, description="Specifies if the SR alert is enabled or not for a QoS-configured vvset. The value for the enableSrAlert will be true only if the name of the SR alert criterion matches with the name of the vvset and the criterion's condition(s) of the SR alert matches with the QoS parameters set.", alias="enableSrAlert")
    generation: Optional[StrictInt] = Field(default=None, description="generation")
    id: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="id of the QoS Configuration")
    io_guarantee_tb: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="iops Maximum Guarantee per Tb", alias="ioGuaranteeTb")
    io_limit_tb: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="iops Maximum Limit per Tb", alias="ioLimitTb")
    iops_max_limit: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="iops Maxmium Limit", alias="iopsMaxLimit")
    last_modified_epoch: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="last modified Epoch", alias="lastModifiedEpoch")
    per_tb: Optional[StrictBool] = Field(default=None, description="Enable of perTb QoS Configuration", alias="perTb")
    system_uid: Optional[StrictStr] = Field(default=None, description="System Id", alias="systemUid")
    system_wwn: Optional[StrictStr] = Field(default=None, description="System WWN", alias="systemWWN")
    target_name: Optional[StrictStr] = Field(default=None, description="Target Name of the QoS Config", alias="targetName")
    target_type: Optional[StrictStr] = Field(default=None, description="Target Type of the QoS Config", alias="targetType")
    uid: Optional[StrictStr] = Field(default=None, description="UID of the QoS Config resource")
    volumes: Optional[List[StrictStr]] = Field(default=None, description="List of volumes")
    __properties: ClassVar[List[str]] = ["bandwidthMaxLimitKiB", "bwGuaranteeTb", "bwLimitTb", "displayname", "domain", "enable", "enableSrAlert", "generation", "id", "ioGuaranteeTb", "ioLimitTb", "iopsMaxLimit", "lastModifiedEpoch", "perTb", "systemUid", "systemWWN", "targetName", "targetType", "uid", "volumes"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DeviceType4AppSetQoSConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if bandwidth_max_limit_ki_b (nullable) is None
        # and model_fields_set contains the field
        if self.bandwidth_max_limit_ki_b is None and "bandwidth_max_limit_ki_b" in self.model_fields_set:
            _dict['bandwidthMaxLimitKiB'] = None

        # set to None if bw_guarantee_tb (nullable) is None
        # and model_fields_set contains the field
        if self.bw_guarantee_tb is None and "bw_guarantee_tb" in self.model_fields_set:
            _dict['bwGuaranteeTb'] = None

        # set to None if bw_limit_tb (nullable) is None
        # and model_fields_set contains the field
        if self.bw_limit_tb is None and "bw_limit_tb" in self.model_fields_set:
            _dict['bwLimitTb'] = None

        # set to None if displayname (nullable) is None
        # and model_fields_set contains the field
        if self.displayname is None and "displayname" in self.model_fields_set:
            _dict['displayname'] = None

        # set to None if domain (nullable) is None
        # and model_fields_set contains the field
        if self.domain is None and "domain" in self.model_fields_set:
            _dict['domain'] = None

        # set to None if generation (nullable) is None
        # and model_fields_set contains the field
        if self.generation is None and "generation" in self.model_fields_set:
            _dict['generation'] = None

        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if io_guarantee_tb (nullable) is None
        # and model_fields_set contains the field
        if self.io_guarantee_tb is None and "io_guarantee_tb" in self.model_fields_set:
            _dict['ioGuaranteeTb'] = None

        # set to None if io_limit_tb (nullable) is None
        # and model_fields_set contains the field
        if self.io_limit_tb is None and "io_limit_tb" in self.model_fields_set:
            _dict['ioLimitTb'] = None

        # set to None if iops_max_limit (nullable) is None
        # and model_fields_set contains the field
        if self.iops_max_limit is None and "iops_max_limit" in self.model_fields_set:
            _dict['iopsMaxLimit'] = None

        # set to None if last_modified_epoch (nullable) is None
        # and model_fields_set contains the field
        if self.last_modified_epoch is None and "last_modified_epoch" in self.model_fields_set:
            _dict['lastModifiedEpoch'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DeviceType4AppSetQoSConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "bandwidthMaxLimitKiB": obj.get("bandwidthMaxLimitKiB"),
            "bwGuaranteeTb": obj.get("bwGuaranteeTb"),
            "bwLimitTb": obj.get("bwLimitTb"),
            "displayname": obj.get("displayname"),
            "domain": obj.get("domain"),
            "enable": obj.get("enable"),
            "enableSrAlert": obj.get("enableSrAlert"),
            "generation": obj.get("generation"),
            "id": obj.get("id"),
            "ioGuaranteeTb": obj.get("ioGuaranteeTb"),
            "ioLimitTb": obj.get("ioLimitTb"),
            "iopsMaxLimit": obj.get("iopsMaxLimit"),
            "lastModifiedEpoch": obj.get("lastModifiedEpoch"),
            "perTb": obj.get("perTb"),
            "systemUid": obj.get("systemUid"),
            "systemWWN": obj.get("systemWWN"),
            "targetName": obj.get("targetName"),
            "targetType": obj.get("targetType"),
            "uid": obj.get("uid"),
            "volumes": obj.get("volumes")
        })
        return _obj


