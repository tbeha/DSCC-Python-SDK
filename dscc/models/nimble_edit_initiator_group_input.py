# coding: utf-8

"""
    Data Services Cloud Console API

    Data Services Cloud Console API

    The version of the OpenAPI document: 1.6.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from dscc.models.nimble_fc_initiator import NimbleFCInitiator
from dscc.models.nimble_fc_tdz_ports import NimbleFCTdzPorts
from dscc.models.nimble_iscsi_initiator import NimbleISCSIInitiator
from dscc.models.nimble_metadata import NimbleMetadata
from dscc.models.nimble_target_subnets import NimbleTargetSubnets
from typing import Optional, Set
from typing_extensions import Self

class NimbleEditInitiatorGroupInput(BaseModel):
    """
    Edit Nimble initiator group input.
    """ # noqa: E501
    app_uuid: Optional[StrictStr] = Field(default=None, description="Application identifier of initiator group. String of up to 255 alphanumeric characters, hyphen, colon, dot and underscore are allowed.")
    description: Optional[StrictStr] = Field(default=None, description="Text description of initiator group. String of up to 255 printable ASCII characters.")
    fc_initiators: Optional[List[Optional[NimbleFCInitiator]]] = Field(default=None, description="List of FC initiators. When create/update fc_initiators, wwpn is required. List of Fibre Channel initiators.")
    fc_tdz_ports: Optional[List[Optional[NimbleFCTdzPorts]]] = Field(default=None, description="List of target Fibre Channel ports with Target Driven Zoning configured on this initiator group. List of target ports.")
    host_type: Optional[StrictStr] = Field(default=None, description="Initiator group host type. Available options are auto and hpux. The default option is auto. This attribute will be applied to all the initiators in the initiator group. Initiators with different host OSes should not be kept in the same initiator group having a non-default host type attribute. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    iscsi_initiators: Optional[List[Optional[NimbleISCSIInitiator]]] = Field(default=None, description="List of iSCSI initiators. When create/update iscsi_initiators, either iqn or ip_address is always required with label.")
    metadata: Optional[List[Optional[NimbleMetadata]]] = Field(default=None, description="Key-value pairs that augment an initiator group's attributes.")
    name: Optional[StrictStr] = Field(default=None, description="Name of initiator group. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    target_subnets: Optional[List[Optional[NimbleTargetSubnets]]] = Field(default=None, description="List of target subnet labels. If specified, discovery and access to volumes will be restricted to to the specified subnets. List of target subnet tables.")
    __properties: ClassVar[List[str]] = ["app_uuid", "description", "fc_initiators", "fc_tdz_ports", "host_type", "iscsi_initiators", "metadata", "name", "target_subnets"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of NimbleEditInitiatorGroupInput from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in fc_initiators (list)
        _items = []
        if self.fc_initiators:
            for _item in self.fc_initiators:
                if _item:
                    _items.append(_item.to_dict())
            _dict['fc_initiators'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in fc_tdz_ports (list)
        _items = []
        if self.fc_tdz_ports:
            for _item in self.fc_tdz_ports:
                if _item:
                    _items.append(_item.to_dict())
            _dict['fc_tdz_ports'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in iscsi_initiators (list)
        _items = []
        if self.iscsi_initiators:
            for _item in self.iscsi_initiators:
                if _item:
                    _items.append(_item.to_dict())
            _dict['iscsi_initiators'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in metadata (list)
        _items = []
        if self.metadata:
            for _item in self.metadata:
                if _item:
                    _items.append(_item.to_dict())
            _dict['metadata'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in target_subnets (list)
        _items = []
        if self.target_subnets:
            for _item in self.target_subnets:
                if _item:
                    _items.append(_item.to_dict())
            _dict['target_subnets'] = _items
        # set to None if app_uuid (nullable) is None
        # and model_fields_set contains the field
        if self.app_uuid is None and "app_uuid" in self.model_fields_set:
            _dict['app_uuid'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if fc_initiators (nullable) is None
        # and model_fields_set contains the field
        if self.fc_initiators is None and "fc_initiators" in self.model_fields_set:
            _dict['fc_initiators'] = None

        # set to None if fc_tdz_ports (nullable) is None
        # and model_fields_set contains the field
        if self.fc_tdz_ports is None and "fc_tdz_ports" in self.model_fields_set:
            _dict['fc_tdz_ports'] = None

        # set to None if host_type (nullable) is None
        # and model_fields_set contains the field
        if self.host_type is None and "host_type" in self.model_fields_set:
            _dict['host_type'] = None

        # set to None if iscsi_initiators (nullable) is None
        # and model_fields_set contains the field
        if self.iscsi_initiators is None and "iscsi_initiators" in self.model_fields_set:
            _dict['iscsi_initiators'] = None

        # set to None if metadata (nullable) is None
        # and model_fields_set contains the field
        if self.metadata is None and "metadata" in self.model_fields_set:
            _dict['metadata'] = None

        # set to None if target_subnets (nullable) is None
        # and model_fields_set contains the field
        if self.target_subnets is None and "target_subnets" in self.model_fields_set:
            _dict['target_subnets'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of NimbleEditInitiatorGroupInput from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "app_uuid": obj.get("app_uuid"),
            "description": obj.get("description"),
            "fc_initiators": [NimbleFCInitiator.from_dict(_item) for _item in obj["fc_initiators"]] if obj.get("fc_initiators") is not None else None,
            "fc_tdz_ports": [NimbleFCTdzPorts.from_dict(_item) for _item in obj["fc_tdz_ports"]] if obj.get("fc_tdz_ports") is not None else None,
            "host_type": obj.get("host_type"),
            "iscsi_initiators": [NimbleISCSIInitiator.from_dict(_item) for _item in obj["iscsi_initiators"]] if obj.get("iscsi_initiators") is not None else None,
            "metadata": [NimbleMetadata.from_dict(_item) for _item in obj["metadata"]] if obj.get("metadata") is not None else None,
            "name": obj.get("name"),
            "target_subnets": [NimbleTargetSubnets.from_dict(_item) for _item in obj["target_subnets"]] if obj.get("target_subnets") is not None else None
        })
        return _obj


