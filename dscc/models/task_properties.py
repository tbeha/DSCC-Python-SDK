# coding: utf-8

"""
    Data Services Cloud Console API

    Data Services Cloud Console API

    The version of the OpenAPI document: 1.6.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from dscc.models.resource_reference import ResourceReference
from dscc.models.task_console_reference import TaskConsoleReference
from dscc.models.task_log_message import TaskLogMessage
from dscc.models.task_properties_error import TaskPropertiesError
from dscc.models.task_properties_parent_task import TaskPropertiesParentTask
from dscc.models.task_properties_source_resource import TaskPropertiesSourceResource
from dscc.models.task_recommendations import TaskRecommendations
from typing import Optional, Set
from typing_extensions import Self

class TaskProperties(BaseModel):
    """
    TaskProperties
    """ # noqa: E501
    additional_details: Optional[TaskConsoleReference] = Field(default=None, description="A link to be displayed in the Tasks UI. This can be used when a task is paused to take the user to the console UI page with information on how to unpause the task, or for more general information when the task is in other states.", alias="additionalDetails")
    associated_resources: Optional[List[ResourceReference]] = Field(default=None, description="Resources that are associated with the task. These may be created by the task or other resources that are involved in the task.", alias="associatedResources")
    child_tasks: Optional[List[ResourceReference]] = Field(default=None, description="A list of sub-tasks that were initiated by this task.", alias="childTasks")
    created_at: Optional[datetime] = Field(default=None, description="The time this task was created.", alias="createdAt")
    display_name: Optional[StrictStr] = Field(default=None, description="The displayed name for the task.", alias="displayName")
    ended_at: Optional[datetime] = Field(default=None, description="The time this task completed.", alias="endedAt")
    error: Optional[TaskPropertiesError] = None
    estimated_running_duration_minutes: Optional[StrictInt] = Field(default=None, description="An estimate of how long the task will run before completing.", alias="estimatedRunningDurationMinutes")
    health_status: Optional[StrictStr] = Field(default=None, description="The health status indicates if any errors or problems have been encountered during the processing of the task.  Expected values are OK, ERROR, WARNING, UNKNOWN, and UNSPECIFIED. ", alias="healthStatus")
    log_messages: Optional[List[TaskLogMessage]] = Field(default=None, description="Time stamped messages that record the progress of the task.", alias="logMessages")
    parent_task: Optional[TaskPropertiesParentTask] = Field(default=None, alias="parentTask")
    progress_percent: Optional[Annotated[int, Field(le=100, strict=True, ge=0)]] = Field(default=None, description="A percentage representation of progress to completion.", alias="progressPercent")
    recommendations: Optional[List[TaskRecommendations]] = Field(default=None, description="Recommendations on how to fix failing tasks.")
    source_resource: Optional[TaskPropertiesSourceResource] = Field(default=None, alias="sourceResource")
    started_at: Optional[datetime] = Field(default=None, description="The time this task was started.", alias="startedAt")
    state: Optional[StrictStr] = Field(default=None, description="A message to indicate the current state of the task, for example the current step in a workflow. Expected values are INITIALIZED, RUNNING, FAILED, SUCCEEDED, TIMEDOUT, PAUSED, and UNSPECIFIED. ")
    suggested_polling_interval_seconds: Optional[StrictInt] = Field(default=None, description="This attribute suggests a suitable interval to use when polling for progress. Where specified this will be based on the frequency with which the task is likely to be updated.", alias="suggestedPollingIntervalSeconds")
    updated_at: Optional[datetime] = Field(default=None, description="The time this task was last updated.", alias="updatedAt")
    user_id: Optional[StrictStr] = Field(default=None, description="The ID or email address of the user that initiated the task.", alias="userId")
    __properties: ClassVar[List[str]] = ["additionalDetails", "associatedResources", "childTasks", "createdAt", "displayName", "endedAt", "error", "estimatedRunningDurationMinutes", "healthStatus", "logMessages", "parentTask", "progressPercent", "recommendations", "sourceResource", "startedAt", "state", "suggestedPollingIntervalSeconds", "updatedAt", "userId"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TaskProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of additional_details
        if self.additional_details:
            _dict['additionalDetails'] = self.additional_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in associated_resources (list)
        _items = []
        if self.associated_resources:
            for _item in self.associated_resources:
                if _item:
                    _items.append(_item.to_dict())
            _dict['associatedResources'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in child_tasks (list)
        _items = []
        if self.child_tasks:
            for _item in self.child_tasks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['childTasks'] = _items
        # override the default output from pydantic by calling `to_dict()` of error
        if self.error:
            _dict['error'] = self.error.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in log_messages (list)
        _items = []
        if self.log_messages:
            for _item in self.log_messages:
                if _item:
                    _items.append(_item.to_dict())
            _dict['logMessages'] = _items
        # override the default output from pydantic by calling `to_dict()` of parent_task
        if self.parent_task:
            _dict['parentTask'] = self.parent_task.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in recommendations (list)
        _items = []
        if self.recommendations:
            for _item in self.recommendations:
                if _item:
                    _items.append(_item.to_dict())
            _dict['recommendations'] = _items
        # override the default output from pydantic by calling `to_dict()` of source_resource
        if self.source_resource:
            _dict['sourceResource'] = self.source_resource.to_dict()
        # set to None if ended_at (nullable) is None
        # and model_fields_set contains the field
        if self.ended_at is None and "ended_at" in self.model_fields_set:
            _dict['endedAt'] = None

        # set to None if started_at (nullable) is None
        # and model_fields_set contains the field
        if self.started_at is None and "started_at" in self.model_fields_set:
            _dict['startedAt'] = None

        # set to None if updated_at (nullable) is None
        # and model_fields_set contains the field
        if self.updated_at is None and "updated_at" in self.model_fields_set:
            _dict['updatedAt'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TaskProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "additionalDetails": TaskConsoleReference.from_dict(obj["additionalDetails"]) if obj.get("additionalDetails") is not None else None,
            "associatedResources": [ResourceReference.from_dict(_item) for _item in obj["associatedResources"]] if obj.get("associatedResources") is not None else None,
            "childTasks": [ResourceReference.from_dict(_item) for _item in obj["childTasks"]] if obj.get("childTasks") is not None else None,
            "createdAt": obj.get("createdAt"),
            "displayName": obj.get("displayName"),
            "endedAt": obj.get("endedAt"),
            "error": TaskPropertiesError.from_dict(obj["error"]) if obj.get("error") is not None else None,
            "estimatedRunningDurationMinutes": obj.get("estimatedRunningDurationMinutes"),
            "healthStatus": obj.get("healthStatus"),
            "logMessages": [TaskLogMessage.from_dict(_item) for _item in obj["logMessages"]] if obj.get("logMessages") is not None else None,
            "parentTask": TaskPropertiesParentTask.from_dict(obj["parentTask"]) if obj.get("parentTask") is not None else None,
            "progressPercent": obj.get("progressPercent"),
            "recommendations": [TaskRecommendations.from_dict(_item) for _item in obj["recommendations"]] if obj.get("recommendations") is not None else None,
            "sourceResource": TaskPropertiesSourceResource.from_dict(obj["sourceResource"]) if obj.get("sourceResource") is not None else None,
            "startedAt": obj.get("startedAt"),
            "state": obj.get("state"),
            "suggestedPollingIntervalSeconds": obj.get("suggestedPollingIntervalSeconds"),
            "updatedAt": obj.get("updatedAt"),
            "userId": obj.get("userId")
        })
        return _obj


