# coding: utf-8

"""
    Data Services Cloud Console API

    Data Services Cloud Console API

    The version of the OpenAPI document: 1.6.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class NimbleReplicationPartnerFilterableFields(BaseModel):
    """
    NimbleReplicationPartnerFilterableFields
    """ # noqa: E501
    array_serial: Optional[StrictStr] = Field(default=None, description="Serial number of group leader array of the partner. Plain string. `Filter, Sort`")
    cfg_sync_status: Optional[StrictStr] = Field(default=None, description="Indicates whether all volumes and volume collections have been synced to the partner. Possible values: N/A, Yes, No `Filter, Sort`")
    creation_time: Optional[StrictInt] = Field(default=None, description="Time when this replication partner was created. Seconds since last epoch i.e. 00:00 January 1, 1970. `Filter, Sort`")
    folder_id: Optional[StrictStr] = Field(default=None, description="The Folder ID within the pool where volumes replicated from this partner will be created. This is not supported for pool partners. A 42 digit hexadecimal number. `Filter, Sort`")
    folder_name: Optional[StrictStr] = Field(default=None, description="The Folder name within the pool where volumes replicated from this partner will be created. String of up to 64 alphanumeric characters, - and . and : are allowed after first character. `Filter, Sort`")
    hostname: Optional[StrictStr] = Field(default=None, description="IP address or hostname of partner interface. This must be the partners Group Management IP address. String of up to 64 alphanumeric characters, - and . and : are allowed after first character. `Filter, Sort`")
    id: Optional[StrictStr] = Field(default=None, description="Identifier for a replication partner. A 42 digit hexadecimal number. `Filter`")
    is_alive: Optional[StrictBool] = Field(default=None, description="Whether the partner is available, and responding to pings. Possible values: true, false `Filter, Sort`")
    name: Optional[StrictStr] = Field(default=None, description="Name of replication partner. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.`Filter, Sort`")
    partner_type: Optional[StrictStr] = Field(default=None, description="Type of the partner, Possible values: 'group' or 'pool'.`Filter, Sort`")
    paused: Optional[StrictBool] = Field(default=None, description="Indicates whether replication traffic from/to this partner has been halted. Possible values: true, false `Filter, Sort`")
    pool_id: Optional[StrictStr] = Field(default=None, description="The pool ID where volumes replicated from this partner will be created. Replica volumes created as clones ignore this parameter and are always created in the same pool as their parent volume. A 42 digit hexadecimal number. `Filter, Sort`")
    pool_name: Optional[StrictStr] = Field(default=None, description="The pool name where volumes replicated from this partner will be created. String of up to 64 alphanumeric characters, - and . and : are allowed after first character. `Filter, Sort`")
    repl_hostname: Optional[StrictStr] = Field(default=None, description="IP address or hostname of partner data interface. String of up to 64 alphanumeric characters, - and . and : are allowed after first character. `Filter, Sort`")
    subnet_label: Optional[StrictStr] = Field(default=None, description="Label of the subnet used to replicate to this partner. String of up to 64 alphanumeric characters, - and . and : are allowed after first character. `Filter, Sort`")
    subnet_netmask: Optional[StrictStr] = Field(default=None, description="Subnet mask used to replicate to this partner. A netmask expressed as a 32 bit binary value must have the highest bit set (2^31) and the lowest bit clear (2^0) with the first zero followed by only zeros. `Filter, Sort`")
    subnet_network: Optional[StrictStr] = Field(default=None, description="Subnet used to replicate to this partner. Four numbers in the range [0,255] separated by periods. `Filter, Sort`")
    subnet_type: Optional[StrictStr] = Field(default=None, description="Type of the subnet used to replicate to this partner. Possible values: invalid, unconfigured, mgmt, data, mgmt_data `Filter, Sort`")
    system_id: Optional[StrictStr] = Field(default=None, description="Identifier for a system or array. A 42 digit hexadecimal number. `Filter`", alias="systemId")
    version: Optional[StrictInt] = Field(default=None, description="Replication version of the partner. Signed 64-bit integer. `Filter, Sort`")
    volume_collection_list_count: Optional[StrictInt] = Field(default=None, description="Count of volume collections that are replicating from/to this partner. Unsigned 64-bit integer. `Filter, Sort`")
    __properties: ClassVar[List[str]] = ["array_serial", "cfg_sync_status", "creation_time", "folder_id", "folder_name", "hostname", "id", "is_alive", "name", "partner_type", "paused", "pool_id", "pool_name", "repl_hostname", "subnet_label", "subnet_netmask", "subnet_network", "subnet_type", "systemId", "version", "volume_collection_list_count"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of NimbleReplicationPartnerFilterableFields from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if array_serial (nullable) is None
        # and model_fields_set contains the field
        if self.array_serial is None and "array_serial" in self.model_fields_set:
            _dict['array_serial'] = None

        # set to None if cfg_sync_status (nullable) is None
        # and model_fields_set contains the field
        if self.cfg_sync_status is None and "cfg_sync_status" in self.model_fields_set:
            _dict['cfg_sync_status'] = None

        # set to None if creation_time (nullable) is None
        # and model_fields_set contains the field
        if self.creation_time is None and "creation_time" in self.model_fields_set:
            _dict['creation_time'] = None

        # set to None if folder_id (nullable) is None
        # and model_fields_set contains the field
        if self.folder_id is None and "folder_id" in self.model_fields_set:
            _dict['folder_id'] = None

        # set to None if folder_name (nullable) is None
        # and model_fields_set contains the field
        if self.folder_name is None and "folder_name" in self.model_fields_set:
            _dict['folder_name'] = None

        # set to None if hostname (nullable) is None
        # and model_fields_set contains the field
        if self.hostname is None and "hostname" in self.model_fields_set:
            _dict['hostname'] = None

        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if is_alive (nullable) is None
        # and model_fields_set contains the field
        if self.is_alive is None and "is_alive" in self.model_fields_set:
            _dict['is_alive'] = None

        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if partner_type (nullable) is None
        # and model_fields_set contains the field
        if self.partner_type is None and "partner_type" in self.model_fields_set:
            _dict['partner_type'] = None

        # set to None if paused (nullable) is None
        # and model_fields_set contains the field
        if self.paused is None and "paused" in self.model_fields_set:
            _dict['paused'] = None

        # set to None if pool_id (nullable) is None
        # and model_fields_set contains the field
        if self.pool_id is None and "pool_id" in self.model_fields_set:
            _dict['pool_id'] = None

        # set to None if pool_name (nullable) is None
        # and model_fields_set contains the field
        if self.pool_name is None and "pool_name" in self.model_fields_set:
            _dict['pool_name'] = None

        # set to None if repl_hostname (nullable) is None
        # and model_fields_set contains the field
        if self.repl_hostname is None and "repl_hostname" in self.model_fields_set:
            _dict['repl_hostname'] = None

        # set to None if subnet_label (nullable) is None
        # and model_fields_set contains the field
        if self.subnet_label is None and "subnet_label" in self.model_fields_set:
            _dict['subnet_label'] = None

        # set to None if subnet_netmask (nullable) is None
        # and model_fields_set contains the field
        if self.subnet_netmask is None and "subnet_netmask" in self.model_fields_set:
            _dict['subnet_netmask'] = None

        # set to None if subnet_network (nullable) is None
        # and model_fields_set contains the field
        if self.subnet_network is None and "subnet_network" in self.model_fields_set:
            _dict['subnet_network'] = None

        # set to None if subnet_type (nullable) is None
        # and model_fields_set contains the field
        if self.subnet_type is None and "subnet_type" in self.model_fields_set:
            _dict['subnet_type'] = None

        # set to None if system_id (nullable) is None
        # and model_fields_set contains the field
        if self.system_id is None and "system_id" in self.model_fields_set:
            _dict['systemId'] = None

        # set to None if version (nullable) is None
        # and model_fields_set contains the field
        if self.version is None and "version" in self.model_fields_set:
            _dict['version'] = None

        # set to None if volume_collection_list_count (nullable) is None
        # and model_fields_set contains the field
        if self.volume_collection_list_count is None and "volume_collection_list_count" in self.model_fields_set:
            _dict['volume_collection_list_count'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of NimbleReplicationPartnerFilterableFields from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "array_serial": obj.get("array_serial"),
            "cfg_sync_status": obj.get("cfg_sync_status"),
            "creation_time": obj.get("creation_time"),
            "folder_id": obj.get("folder_id"),
            "folder_name": obj.get("folder_name"),
            "hostname": obj.get("hostname"),
            "id": obj.get("id"),
            "is_alive": obj.get("is_alive"),
            "name": obj.get("name"),
            "partner_type": obj.get("partner_type"),
            "paused": obj.get("paused"),
            "pool_id": obj.get("pool_id"),
            "pool_name": obj.get("pool_name"),
            "repl_hostname": obj.get("repl_hostname"),
            "subnet_label": obj.get("subnet_label"),
            "subnet_netmask": obj.get("subnet_netmask"),
            "subnet_network": obj.get("subnet_network"),
            "subnet_type": obj.get("subnet_type"),
            "systemId": obj.get("systemId"),
            "version": obj.get("version"),
            "volume_collection_list_count": obj.get("volume_collection_list_count")
        })
        return _obj


