# coding: utf-8

"""
    Data Services Cloud Console API

    Data Services Cloud Console API

    The version of the OpenAPI document: 1.6.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from dscc.models.nic_details import NICDetails
from dscc.models.public_key_details import PublicKeyDetails
from dscc.models.upgrade_details import UpgradeDetails
from dscc.models.z_conf_i_paddrs import ZConfIPaddrs
from typing import Optional, Set
from typing_extensions import Self

class NimbleArray(BaseModel):
    """
    NimbleArray
    """ # noqa: E501
    all_flash: Optional[StrictBool] = Field(default=None, description="Whether it is an all-flash array.")
    allow_lower_limits: Optional[StrictBool] = Field(default=None, description="Setting this field to 'true'  will allow the addition of an array with lower limits to a pool with higher limits.")
    available_bytes: Optional[StrictInt] = Field(default=None, description="The available space of the array.")
    create_pool: Optional[StrictBool] = Field(default=None, description="Whether to create associated pool during array create.")
    creation_time: Optional[StrictInt] = Field(default=None, description="Time when this array object was created. Seconds since last epoch i.e. 00:00 January 1, 1970.")
    ctrlr_a_support_ip: Optional[StrictStr] = Field(default=None, description="Controller A Support IP address.")
    ctrlr_b_support_ip: Optional[StrictStr] = Field(default=None, description="Controller B Support IP address.")
    customer_id: Optional[StrictStr] = Field(default=None, description="customerId", alias="customerId")
    dedupe_capacity_bytes: Optional[StrictInt] = Field(default=None, description="The dedupe capacity of a hybrid array. Does not apply to all-flash arrays.")
    dedupe_usage_bytes: Optional[StrictInt] = Field(default=None, description="The dedupe usage of a hybrid array. Does not apply to all-flash arrays.")
    extended_model: Optional[StrictStr] = Field(default=None, description="Extended model of the array. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    fc_port_count: Optional[StrictInt] = Field(default=None, description="Count of Fibre Channel Ports installed on the array.")
    force: Optional[StrictBool] = Field(default=None, description="Forcibly delete the specified array.")
    full_name: Optional[StrictStr] = Field(default=None, description="The array's fully qualified name. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    generation: Optional[StrictInt] = Field(default=None, description="generation")
    gig_nic_port_count: Optional[StrictInt] = Field(default=None, description="Count of 1G NIC Ports installed on the array.")
    group_state: Optional[StrictStr] = Field(default=None, description="Group state. State of the array in the group. Possible values: 'invalid', 'initialized', 'unused', 'removing'.")
    id: Optional[StrictStr] = Field(default=None, description="Identifier for array. A 42 digit hexadecimal number.")
    is_fully_dedupe_capable: Optional[StrictBool] = Field(default=None, description="Flag specifies if the array fully capable to dedupe its usable capacity or not.")
    is_sfa: Optional[StrictBool] = Field(default=None, description="Flag specifies if the array is sfa or not.")
    is_supported_hw_config: Optional[StrictBool] = Field(default=None, description="Whether it is a supported hardware config.")
    last_modified: Optional[StrictInt] = Field(default=None, description="Time when this array object was last modified. Seconds since last epoch i.e. 00:00 January 1, 1970.")
    model: Optional[StrictStr] = Field(default=None, description="Array model. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    model_sub_type: Optional[StrictStr] = Field(default=None, description="Array model sub-type.")
    name: Optional[StrictStr] = Field(default=None, description="The user provided name of the array. It is also the array's hostname. String of up to 63 alphanumeric and can include hyphens characters but cannot start with hyphen.")
    nic_list: Optional[List[Optional[NICDetails]]] = Field(default=None, description="List of NICs information. Used while creating an array.")
    pending_delete_bytes: Optional[StrictInt] = Field(default=None, description="The pending delete bytes in he tarray.")
    pool_description: Optional[StrictStr] = Field(default=None, description="Text description of the pool to be created during array creation. String of up to 255 printable ASCII characters.")
    pool_id: Optional[StrictStr] = Field(default=None, description="ID of pool to which this is a member. A 42 digit hexadecimal number.")
    pool_name: Optional[StrictStr] = Field(default=None, description="Name of pool to which this is a member. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    public_key: Optional[PublicKeyDetails] = None
    raw_capacity_bytes: Optional[StrictInt] = Field(default=None, description="The raw capacity bytes of the array.")
    resource_uri: Optional[StrictStr] = Field(default=None, description="Link to the object URI", alias="resourceUri")
    role: Optional[StrictStr] = Field(default=None, description="Role of an array in the group. Possible values: 'leader', 'non_member', 'invalid', 'backup_leader', 'member', 'failed'.")
    search_name: Optional[StrictStr] = Field(default=None, description="The array name used for object search. Alphanumeric string, up to 64 characters including hyphen, period, colon.")
    secondary_mgmt_ip: Optional[StrictStr] = Field(default=None, description="Secondary management IP address for the Group.")
    serial: Optional[StrictStr] = Field(default=None, description="Serial number of the array.")
    snap_compression: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The compression rate of snapshots in the array expressed as ratio. Fraction expressed as floating point number.")
    snap_saved_bytes: Optional[StrictInt] = Field(default=None, description="The saved space of snapshots in the array.")
    snap_space_reduction: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The space reduction rate of snapshots in the array expressed as ratio. Fraction expressed as floating point number.")
    snap_usage_bytes: Optional[StrictInt] = Field(default=None, description="The compressed usage of snapshots in array.")
    snap_usage_uncompressed_bytes: Optional[StrictInt] = Field(default=None, description="Snap usage uncompressed bytes.")
    status: Optional[StrictStr] = Field(default=None, description="Reachability status of the array in the group. Possible values: 'unreachable', 'reachable'.")
    ten_gig_sfp_nic_port_count: Optional[StrictInt] = Field(default=None, description="Count of 10G SFP NIC Ports installed on the array.")
    ten_gig_t_nic_port_count: Optional[StrictInt] = Field(default=None, description="Count of 10G BaseT NIC Ports installed on the array.")
    upgrade: Optional[UpgradeDetails] = None
    usable_cache_capacity_bytes: Optional[StrictInt] = Field(default=None, description="Usable cache capacity in bytes.")
    usable_capacity_bytes: Optional[StrictInt] = Field(default=None, description="The usable capacity bytes of the array.")
    usage: Optional[StrictInt] = Field(default=None, description="Used space of the array in bytes.")
    usage_valid: Optional[StrictBool] = Field(default=None, description="Indicates whether the usage of the array is valid.")
    version: Optional[StrictStr] = Field(default=None, description="Software version of the array. String of up to 64 alphanumeric characters, - and . and : are allowed after first character.")
    vol_compression: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The compression rate of volumes in the array expressed as ratio. Fraction expressed as floating point number.")
    vol_saved_bytes: Optional[StrictInt] = Field(default=None, description="The saved space of volumes in the array.")
    vol_usage_bytes: Optional[StrictInt] = Field(default=None, description="The compressed usage of volumes in the array.")
    vol_usage_uncompressed_bytes: Optional[StrictInt] = Field(default=None, description="The volume usage uncompressed bytes.")
    zconf_ipaddrs: Optional[List[Optional[ZConfIPaddrs]]] = Field(default=None, description="List of link-local zero-configuration addresses of the array.")
    __properties: ClassVar[List[str]] = ["all_flash", "allow_lower_limits", "available_bytes", "create_pool", "creation_time", "ctrlr_a_support_ip", "ctrlr_b_support_ip", "customerId", "dedupe_capacity_bytes", "dedupe_usage_bytes", "extended_model", "fc_port_count", "force", "full_name", "generation", "gig_nic_port_count", "group_state", "id", "is_fully_dedupe_capable", "is_sfa", "is_supported_hw_config", "last_modified", "model", "model_sub_type", "name", "nic_list", "pending_delete_bytes", "pool_description", "pool_id", "pool_name", "public_key", "raw_capacity_bytes", "resourceUri", "role", "search_name", "secondary_mgmt_ip", "serial", "snap_compression", "snap_saved_bytes", "snap_space_reduction", "snap_usage_bytes", "snap_usage_uncompressed_bytes", "status", "ten_gig_sfp_nic_port_count", "ten_gig_t_nic_port_count", "upgrade", "usable_cache_capacity_bytes", "usable_capacity_bytes", "usage", "usage_valid", "version", "vol_compression", "vol_saved_bytes", "vol_usage_bytes", "vol_usage_uncompressed_bytes", "zconf_ipaddrs"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of NimbleArray from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in nic_list (list)
        _items = []
        if self.nic_list:
            for _item in self.nic_list:
                if _item:
                    _items.append(_item.to_dict())
            _dict['nic_list'] = _items
        # override the default output from pydantic by calling `to_dict()` of public_key
        if self.public_key:
            _dict['public_key'] = self.public_key.to_dict()
        # override the default output from pydantic by calling `to_dict()` of upgrade
        if self.upgrade:
            _dict['upgrade'] = self.upgrade.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in zconf_ipaddrs (list)
        _items = []
        if self.zconf_ipaddrs:
            for _item in self.zconf_ipaddrs:
                if _item:
                    _items.append(_item.to_dict())
            _dict['zconf_ipaddrs'] = _items
        # set to None if all_flash (nullable) is None
        # and model_fields_set contains the field
        if self.all_flash is None and "all_flash" in self.model_fields_set:
            _dict['all_flash'] = None

        # set to None if allow_lower_limits (nullable) is None
        # and model_fields_set contains the field
        if self.allow_lower_limits is None and "allow_lower_limits" in self.model_fields_set:
            _dict['allow_lower_limits'] = None

        # set to None if available_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.available_bytes is None and "available_bytes" in self.model_fields_set:
            _dict['available_bytes'] = None

        # set to None if create_pool (nullable) is None
        # and model_fields_set contains the field
        if self.create_pool is None and "create_pool" in self.model_fields_set:
            _dict['create_pool'] = None

        # set to None if creation_time (nullable) is None
        # and model_fields_set contains the field
        if self.creation_time is None and "creation_time" in self.model_fields_set:
            _dict['creation_time'] = None

        # set to None if ctrlr_a_support_ip (nullable) is None
        # and model_fields_set contains the field
        if self.ctrlr_a_support_ip is None and "ctrlr_a_support_ip" in self.model_fields_set:
            _dict['ctrlr_a_support_ip'] = None

        # set to None if ctrlr_b_support_ip (nullable) is None
        # and model_fields_set contains the field
        if self.ctrlr_b_support_ip is None and "ctrlr_b_support_ip" in self.model_fields_set:
            _dict['ctrlr_b_support_ip'] = None

        # set to None if customer_id (nullable) is None
        # and model_fields_set contains the field
        if self.customer_id is None and "customer_id" in self.model_fields_set:
            _dict['customerId'] = None

        # set to None if dedupe_capacity_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.dedupe_capacity_bytes is None and "dedupe_capacity_bytes" in self.model_fields_set:
            _dict['dedupe_capacity_bytes'] = None

        # set to None if dedupe_usage_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.dedupe_usage_bytes is None and "dedupe_usage_bytes" in self.model_fields_set:
            _dict['dedupe_usage_bytes'] = None

        # set to None if extended_model (nullable) is None
        # and model_fields_set contains the field
        if self.extended_model is None and "extended_model" in self.model_fields_set:
            _dict['extended_model'] = None

        # set to None if fc_port_count (nullable) is None
        # and model_fields_set contains the field
        if self.fc_port_count is None and "fc_port_count" in self.model_fields_set:
            _dict['fc_port_count'] = None

        # set to None if force (nullable) is None
        # and model_fields_set contains the field
        if self.force is None and "force" in self.model_fields_set:
            _dict['force'] = None

        # set to None if full_name (nullable) is None
        # and model_fields_set contains the field
        if self.full_name is None and "full_name" in self.model_fields_set:
            _dict['full_name'] = None

        # set to None if generation (nullable) is None
        # and model_fields_set contains the field
        if self.generation is None and "generation" in self.model_fields_set:
            _dict['generation'] = None

        # set to None if gig_nic_port_count (nullable) is None
        # and model_fields_set contains the field
        if self.gig_nic_port_count is None and "gig_nic_port_count" in self.model_fields_set:
            _dict['gig_nic_port_count'] = None

        # set to None if group_state (nullable) is None
        # and model_fields_set contains the field
        if self.group_state is None and "group_state" in self.model_fields_set:
            _dict['group_state'] = None

        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if is_fully_dedupe_capable (nullable) is None
        # and model_fields_set contains the field
        if self.is_fully_dedupe_capable is None and "is_fully_dedupe_capable" in self.model_fields_set:
            _dict['is_fully_dedupe_capable'] = None

        # set to None if is_sfa (nullable) is None
        # and model_fields_set contains the field
        if self.is_sfa is None and "is_sfa" in self.model_fields_set:
            _dict['is_sfa'] = None

        # set to None if is_supported_hw_config (nullable) is None
        # and model_fields_set contains the field
        if self.is_supported_hw_config is None and "is_supported_hw_config" in self.model_fields_set:
            _dict['is_supported_hw_config'] = None

        # set to None if last_modified (nullable) is None
        # and model_fields_set contains the field
        if self.last_modified is None and "last_modified" in self.model_fields_set:
            _dict['last_modified'] = None

        # set to None if model (nullable) is None
        # and model_fields_set contains the field
        if self.model is None and "model" in self.model_fields_set:
            _dict['model'] = None

        # set to None if model_sub_type (nullable) is None
        # and model_fields_set contains the field
        if self.model_sub_type is None and "model_sub_type" in self.model_fields_set:
            _dict['model_sub_type'] = None

        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if nic_list (nullable) is None
        # and model_fields_set contains the field
        if self.nic_list is None and "nic_list" in self.model_fields_set:
            _dict['nic_list'] = None

        # set to None if pending_delete_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.pending_delete_bytes is None and "pending_delete_bytes" in self.model_fields_set:
            _dict['pending_delete_bytes'] = None

        # set to None if pool_description (nullable) is None
        # and model_fields_set contains the field
        if self.pool_description is None and "pool_description" in self.model_fields_set:
            _dict['pool_description'] = None

        # set to None if pool_id (nullable) is None
        # and model_fields_set contains the field
        if self.pool_id is None and "pool_id" in self.model_fields_set:
            _dict['pool_id'] = None

        # set to None if pool_name (nullable) is None
        # and model_fields_set contains the field
        if self.pool_name is None and "pool_name" in self.model_fields_set:
            _dict['pool_name'] = None

        # set to None if public_key (nullable) is None
        # and model_fields_set contains the field
        if self.public_key is None and "public_key" in self.model_fields_set:
            _dict['public_key'] = None

        # set to None if raw_capacity_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.raw_capacity_bytes is None and "raw_capacity_bytes" in self.model_fields_set:
            _dict['raw_capacity_bytes'] = None

        # set to None if resource_uri (nullable) is None
        # and model_fields_set contains the field
        if self.resource_uri is None and "resource_uri" in self.model_fields_set:
            _dict['resourceUri'] = None

        # set to None if role (nullable) is None
        # and model_fields_set contains the field
        if self.role is None and "role" in self.model_fields_set:
            _dict['role'] = None

        # set to None if search_name (nullable) is None
        # and model_fields_set contains the field
        if self.search_name is None and "search_name" in self.model_fields_set:
            _dict['search_name'] = None

        # set to None if secondary_mgmt_ip (nullable) is None
        # and model_fields_set contains the field
        if self.secondary_mgmt_ip is None and "secondary_mgmt_ip" in self.model_fields_set:
            _dict['secondary_mgmt_ip'] = None

        # set to None if serial (nullable) is None
        # and model_fields_set contains the field
        if self.serial is None and "serial" in self.model_fields_set:
            _dict['serial'] = None

        # set to None if snap_compression (nullable) is None
        # and model_fields_set contains the field
        if self.snap_compression is None and "snap_compression" in self.model_fields_set:
            _dict['snap_compression'] = None

        # set to None if snap_saved_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.snap_saved_bytes is None and "snap_saved_bytes" in self.model_fields_set:
            _dict['snap_saved_bytes'] = None

        # set to None if snap_space_reduction (nullable) is None
        # and model_fields_set contains the field
        if self.snap_space_reduction is None and "snap_space_reduction" in self.model_fields_set:
            _dict['snap_space_reduction'] = None

        # set to None if snap_usage_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.snap_usage_bytes is None and "snap_usage_bytes" in self.model_fields_set:
            _dict['snap_usage_bytes'] = None

        # set to None if snap_usage_uncompressed_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.snap_usage_uncompressed_bytes is None and "snap_usage_uncompressed_bytes" in self.model_fields_set:
            _dict['snap_usage_uncompressed_bytes'] = None

        # set to None if status (nullable) is None
        # and model_fields_set contains the field
        if self.status is None and "status" in self.model_fields_set:
            _dict['status'] = None

        # set to None if ten_gig_sfp_nic_port_count (nullable) is None
        # and model_fields_set contains the field
        if self.ten_gig_sfp_nic_port_count is None and "ten_gig_sfp_nic_port_count" in self.model_fields_set:
            _dict['ten_gig_sfp_nic_port_count'] = None

        # set to None if ten_gig_t_nic_port_count (nullable) is None
        # and model_fields_set contains the field
        if self.ten_gig_t_nic_port_count is None and "ten_gig_t_nic_port_count" in self.model_fields_set:
            _dict['ten_gig_t_nic_port_count'] = None

        # set to None if upgrade (nullable) is None
        # and model_fields_set contains the field
        if self.upgrade is None and "upgrade" in self.model_fields_set:
            _dict['upgrade'] = None

        # set to None if usable_cache_capacity_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.usable_cache_capacity_bytes is None and "usable_cache_capacity_bytes" in self.model_fields_set:
            _dict['usable_cache_capacity_bytes'] = None

        # set to None if usable_capacity_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.usable_capacity_bytes is None and "usable_capacity_bytes" in self.model_fields_set:
            _dict['usable_capacity_bytes'] = None

        # set to None if usage (nullable) is None
        # and model_fields_set contains the field
        if self.usage is None and "usage" in self.model_fields_set:
            _dict['usage'] = None

        # set to None if usage_valid (nullable) is None
        # and model_fields_set contains the field
        if self.usage_valid is None and "usage_valid" in self.model_fields_set:
            _dict['usage_valid'] = None

        # set to None if version (nullable) is None
        # and model_fields_set contains the field
        if self.version is None and "version" in self.model_fields_set:
            _dict['version'] = None

        # set to None if vol_compression (nullable) is None
        # and model_fields_set contains the field
        if self.vol_compression is None and "vol_compression" in self.model_fields_set:
            _dict['vol_compression'] = None

        # set to None if vol_saved_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.vol_saved_bytes is None and "vol_saved_bytes" in self.model_fields_set:
            _dict['vol_saved_bytes'] = None

        # set to None if vol_usage_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.vol_usage_bytes is None and "vol_usage_bytes" in self.model_fields_set:
            _dict['vol_usage_bytes'] = None

        # set to None if vol_usage_uncompressed_bytes (nullable) is None
        # and model_fields_set contains the field
        if self.vol_usage_uncompressed_bytes is None and "vol_usage_uncompressed_bytes" in self.model_fields_set:
            _dict['vol_usage_uncompressed_bytes'] = None

        # set to None if zconf_ipaddrs (nullable) is None
        # and model_fields_set contains the field
        if self.zconf_ipaddrs is None and "zconf_ipaddrs" in self.model_fields_set:
            _dict['zconf_ipaddrs'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of NimbleArray from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "all_flash": obj.get("all_flash"),
            "allow_lower_limits": obj.get("allow_lower_limits"),
            "available_bytes": obj.get("available_bytes"),
            "create_pool": obj.get("create_pool"),
            "creation_time": obj.get("creation_time"),
            "ctrlr_a_support_ip": obj.get("ctrlr_a_support_ip"),
            "ctrlr_b_support_ip": obj.get("ctrlr_b_support_ip"),
            "customerId": obj.get("customerId"),
            "dedupe_capacity_bytes": obj.get("dedupe_capacity_bytes"),
            "dedupe_usage_bytes": obj.get("dedupe_usage_bytes"),
            "extended_model": obj.get("extended_model"),
            "fc_port_count": obj.get("fc_port_count"),
            "force": obj.get("force"),
            "full_name": obj.get("full_name"),
            "generation": obj.get("generation"),
            "gig_nic_port_count": obj.get("gig_nic_port_count"),
            "group_state": obj.get("group_state"),
            "id": obj.get("id"),
            "is_fully_dedupe_capable": obj.get("is_fully_dedupe_capable"),
            "is_sfa": obj.get("is_sfa"),
            "is_supported_hw_config": obj.get("is_supported_hw_config"),
            "last_modified": obj.get("last_modified"),
            "model": obj.get("model"),
            "model_sub_type": obj.get("model_sub_type"),
            "name": obj.get("name"),
            "nic_list": [NICDetails.from_dict(_item) for _item in obj["nic_list"]] if obj.get("nic_list") is not None else None,
            "pending_delete_bytes": obj.get("pending_delete_bytes"),
            "pool_description": obj.get("pool_description"),
            "pool_id": obj.get("pool_id"),
            "pool_name": obj.get("pool_name"),
            "public_key": PublicKeyDetails.from_dict(obj["public_key"]) if obj.get("public_key") is not None else None,
            "raw_capacity_bytes": obj.get("raw_capacity_bytes"),
            "resourceUri": obj.get("resourceUri"),
            "role": obj.get("role"),
            "search_name": obj.get("search_name"),
            "secondary_mgmt_ip": obj.get("secondary_mgmt_ip"),
            "serial": obj.get("serial"),
            "snap_compression": obj.get("snap_compression"),
            "snap_saved_bytes": obj.get("snap_saved_bytes"),
            "snap_space_reduction": obj.get("snap_space_reduction"),
            "snap_usage_bytes": obj.get("snap_usage_bytes"),
            "snap_usage_uncompressed_bytes": obj.get("snap_usage_uncompressed_bytes"),
            "status": obj.get("status"),
            "ten_gig_sfp_nic_port_count": obj.get("ten_gig_sfp_nic_port_count"),
            "ten_gig_t_nic_port_count": obj.get("ten_gig_t_nic_port_count"),
            "upgrade": UpgradeDetails.from_dict(obj["upgrade"]) if obj.get("upgrade") is not None else None,
            "usable_cache_capacity_bytes": obj.get("usable_cache_capacity_bytes"),
            "usable_capacity_bytes": obj.get("usable_capacity_bytes"),
            "usage": obj.get("usage"),
            "usage_valid": obj.get("usage_valid"),
            "version": obj.get("version"),
            "vol_compression": obj.get("vol_compression"),
            "vol_saved_bytes": obj.get("vol_saved_bytes"),
            "vol_usage_bytes": obj.get("vol_usage_bytes"),
            "vol_usage_uncompressed_bytes": obj.get("vol_usage_uncompressed_bytes"),
            "zconf_ipaddrs": [ZConfIPaddrs.from_dict(_item) for _item in obj["zconf_ipaddrs"]] if obj.get("zconf_ipaddrs") is not None else None
        })
        return _obj


