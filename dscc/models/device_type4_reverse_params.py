# coding: utf-8

"""
    Data Services Cloud Console API

    Data Services Cloud Console API

    The version of the OpenAPI document: 1.6.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class DeviceType4ReverseParams(BaseModel):
    """
    DeviceType4ReverseParams
    """ # noqa: E501
    current: Optional[StrictBool] = Field(default=None, description="Changes both the role and the direction of data flow between the protected volume sets. For example, if the roles of the protected volume sets are \"primary\" and \"secondary\", issuing the -current option to the reverse operation will result in the roles of the protected volume set becoming \"secondary-rev\" and \"primary-rev\" respectively, and the direction data flows between the groups is reversed. Since the -current option actually reverses the direction of data replication, it requires the protected volume set be stopped.This option must be used with care to ensure the protected volume sets do not end up in a non-deterministic state (like \"secondary\", \"secondary-rev\" for example) and to ensure data loss does not occur by inadvertently changing the direction of data flow and resyncing old data on top of newer data.")
    local_group_direction: Optional[StrictBool] = Field(default=None, description="This option only applies to the reverse operation, and only when the -natural or -current options to the reverse operation are specified. Specifying this option with the reverse operation and an associated -natural or -current option will only affect the system where the reverse command is issued, and will not be mirrored to any other arrays in the Remote Copy configuration.", alias="localGroupDirection")
    natural: Optional[StrictBool] = Field(default=None, description="Changes the role of the protected volume sets but not the direction of data flow between the groups on the arrays. For example, if the role of the protected volume sets are \"primary\" and \"secondary\", issuing the -natural option with the reverse operation will result in the role of the groups becoming \"primary-rev\" and \"secondary-rev\" respectively. The direction of data flow between the protected volume sets is not affected, only the roles. Since the -natural option does not change the direction of data flow between the protected volume sets, it does not require the protected volume sets be stopped. This option must be used with care to ensure the protected volume sets do not end up in a non-deterministic state (like \"secondary\", \"secondary-rev\" for example) and to ensure data loss does not occur by inadvertently changing the direction of data flow and resyncing old data on top of newer data.")
    no_snapshot: Optional[StrictBool] = Field(default=None, description="Specifies that snapshots are not taken of the protected volume sets that are switched from secondary to primary. Additionally, existing snapshots are deleted if the protected volume sets are switched from primary to secondary. The use of this option may result in a full synchronization of the secondary volumes.", alias="noSnapshot")
    skip_promote: Optional[StrictBool] = Field(default=None, description="Specifies that the synchronized snapshots of the protected volume set that are switched from primary to secondary should not be promoted to the base volume. The incorrect use of this option can lead to the primary and secondary volumes not being consistent.", alias="skipPromote")
    stop_groups: Optional[StrictBool] = Field(default=None, description="Specifies that the system stops the replication before performing the reverse action.", alias="stopGroups")
    target_name: Optional[StrictStr] = Field(default=None, description="Replication partner name (target name) on which the reverse action to be performed.", alias="targetName")
    __properties: ClassVar[List[str]] = ["current", "localGroupDirection", "natural", "noSnapshot", "skipPromote", "stopGroups", "targetName"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DeviceType4ReverseParams from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if current (nullable) is None
        # and model_fields_set contains the field
        if self.current is None and "current" in self.model_fields_set:
            _dict['current'] = None

        # set to None if local_group_direction (nullable) is None
        # and model_fields_set contains the field
        if self.local_group_direction is None and "local_group_direction" in self.model_fields_set:
            _dict['localGroupDirection'] = None

        # set to None if natural (nullable) is None
        # and model_fields_set contains the field
        if self.natural is None and "natural" in self.model_fields_set:
            _dict['natural'] = None

        # set to None if no_snapshot (nullable) is None
        # and model_fields_set contains the field
        if self.no_snapshot is None and "no_snapshot" in self.model_fields_set:
            _dict['noSnapshot'] = None

        # set to None if skip_promote (nullable) is None
        # and model_fields_set contains the field
        if self.skip_promote is None and "skip_promote" in self.model_fields_set:
            _dict['skipPromote'] = None

        # set to None if stop_groups (nullable) is None
        # and model_fields_set contains the field
        if self.stop_groups is None and "stop_groups" in self.model_fields_set:
            _dict['stopGroups'] = None

        # set to None if target_name (nullable) is None
        # and model_fields_set contains the field
        if self.target_name is None and "target_name" in self.model_fields_set:
            _dict['targetName'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DeviceType4ReverseParams from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "current": obj.get("current"),
            "localGroupDirection": obj.get("localGroupDirection"),
            "natural": obj.get("natural"),
            "noSnapshot": obj.get("noSnapshot"),
            "skipPromote": obj.get("skipPromote"),
            "stopGroups": obj.get("stopGroups"),
            "targetName": obj.get("targetName")
        })
        return _obj


